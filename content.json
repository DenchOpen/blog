{"posts":[{"title":"Android专栏-BaseQuickAdapterHelper","text":"Android专栏-BaseQuickAdapterHelper0x01 自动加载更多-LoadingFooterView12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import android.view.Viewimport android.view.ViewGroupimport com.chad.library.adapter.base.loadmore.BaseLoadMoreViewimport com.chad.library.adapter.base.loadmore.LoadMoreStatusimport com.chad.library.adapter.base.util.getItemViewimport com.chad.library.adapter.base.viewholder.BaseViewHolderclass LoadingFooterView : BaseLoadMoreView() { private var loadingView: LoadingPagView? = null override fun getRootView(parent: ViewGroup): View { val rootView = parent.getItemView(R.layout.ui_footer_adapter_load_more) loadingView = rootView.findViewById(R.id.loadingView) return rootView } override fun getLoadingView(holder: BaseViewHolder): View { return holder.getView(R.id.loadingView) } override fun getLoadComplete(holder: BaseViewHolder): View { return holder.getView(R.id.fakeView) } override fun getLoadEndView(holder: BaseViewHolder): View { return holder.getView(R.id.endView) } override fun getLoadFailView(holder: BaseViewHolder): View { return holder.getView(R.id.fakeView) } override fun convert(holder: BaseViewHolder, position: Int, loadMoreStatus: LoadMoreStatus) { super.convert(holder, position, loadMoreStatus) when (loadMoreStatus) { LoadMoreStatus.Complete -&gt; { loadingView?.stopPlay() } LoadMoreStatus.Loading -&gt; { loadingView?.startPlay() } LoadMoreStatus.Fail -&gt; { } LoadMoreStatus.End -&gt; { loadingView?.stopPlay() } } }}","link":"/blog/2021/05/25/Android%E4%B8%93%E6%A0%8F-BaseQuickAdapterHelper/"},{"title":"FileProvider 的使用","text":"FileProvider 的使用Dev Doc https://developer.android.google.cn/reference/androidx/core/content/FileProvider 0x01 定义一个FileProvider在 androidx 包提供的 FileProvider 提供了 生成文件Uri 的功能。 在 manifest 文件中，声明一个 provider 123456789101112131415161718&lt;manifest&gt; ... &lt;application&gt; ... &lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;${applicationId}.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot; tools:replace=&quot;android:authorities&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; tools:replace=&quot;android:resource&quot; /&gt; &lt;/provider&gt; ... &lt;/application&gt;&lt;/manifest&gt; 0x02 可用文件路径配置在 res/xml/file_paths.xml 下配置可用的文件路径，FileProvider 只能生成配置了的文件Uri。每个你想要生成Uri的文件路径都需要在 paths 下面定义。 123456789&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;files-path name=&quot;my_images&quot; path=&quot;images/&quot;/&gt; &lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; &lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt; &lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; &lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; &lt;external-media-path name=&quot;name&quot; path=&quot;path&quot; /&gt; ...&lt;/paths&gt; 0x03 生成一个Uri和其他 app 共享一个文件，你需要生成一个Uri。 123456789File imagePath = new File(Context.getFilesDir(), &quot;my_images&quot;);File newFile = new File(imagePath, &quot;default_image.jpg&quot;);Uri uriForFile;if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { uriForFile = FileProvider.getUriForFile(mContext, mContext.getPackageName() + &quot;.fileprovider&quot;, newFile);} else { uriForFile = Uri.parse(&quot;file://&quot; + newFile.toString());} getUriForFile() 返回一个 content URI content://com.mydomain.fileprovider/my_images/default_image.jpg. 0x04 授予权限123shareContentIntent.setClipData(ClipData.newRawUri(&quot;&quot;, contentUri));shareContentIntent.addFlags( Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); Put the content URI in an Intent by calling setData(). Call the method Intent.setFlags() with either Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION or both. Send the Intent to another app. Most often, you do this by calling setResult(). 0x05 提供Uri给其他app12345// 使用uriIntent i = new Intent(Intent.ACTION_VIEW);i.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);i.setDataAndType(uriForFile, &quot;application/vnd.android.package-archive&quot;);mContext.startActivity(i);","link":"/blog/2021/12/07/Android%E4%B8%93%E6%A0%8F-FileProvider/"},{"title":"Android专栏-JavaCrash默认处理","text":"Java Crash 默认处理CrashHandler 处理 Java 异常流程： 区分Debug模式和Release模式、主进程和子进程、主线程和子线程来处理 捕获Activity的生命周期内异常，并主动杀死Activity View绘制流程异常捕获 自定义上报 CrashHandler 源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402import android.os.Buildimport android.os.Environmentimport android.os.Handlerimport android.os.Looperimport android.text.TextUtilsimport android.util.Logimport com.alibaba.ha.adapter.AliHaAdapterimport com.rrtv.action.manager.ThreadPoolManagerimport com.rrtv.utils.utils.UiUtilsimport java.io.ByteArrayInputStreamimport java.io.Fileimport java.io.FileOutputStreamimport java.io.IOExceptionimport java.lang.reflect.Fieldimport java.text.DateFormatimport java.text.SimpleDateFormatimport java.util.*/** * Java Crash 默认处理 */class CrashHandler : Thread.UncaughtExceptionHandler { private var isDebug = false private var isMainProcess = false private var sActivityKiller: IActivityKiller? = null companion object { private const val TAG = &quot;CrashHandler&quot; private var instance = CrashHandler() @Volatile @JvmStatic private var hasInit = false /** * 初始化 * * 在 @link Application#onCreate() 方法中 install() * * @param isDebug 是否debug模式 BuildConfig.DEBUG * @param isMainProcess 是否是主进程 android.os.Process.myPid() */ @JvmStatic fun install(isDebug: Boolean, isMainProcess: Boolean) { if (!hasInit) { synchronized(CrashHandler::class.java) { if (!hasInit) { Log.d(TAG, &quot;install: isDebug = $isDebug, mainPid = $isMainProcess&quot;) hasInit = true instance.setup(isDebug, isMainProcess) Log.d(TAG, &quot;install success.&quot;) } } } } } private fun setup(isDebug: Boolean, isMainProcess: Boolean) { Log.d(TAG, &quot;setup:&quot;) this.isDebug = isDebug this.isMainProcess = isMainProcess Thread.setDefaultUncaughtExceptionHandler(this) if (!isDebug &amp;&amp; isMainProcess) { // release 模式防止主线程奔溃 Handler(Looper.getMainLooper()).post { while (true) { try { Looper.loop() } catch (e: Exception) { handleLooperException(e) } } } try { // 生命周期的 ActivityKiller initActivityKiller() } catch (e: Exception) { Log.e(TAG, &quot;拦截生命周期失败&quot;, e) } } } /** * 替换ActivityThread.mH.mCallback，实现拦截Activity生命周期，直接忽略生命周期的异常的话会导致黑屏，目前 * 会调用ActivityManager的finishActivity结束掉生命周期抛出异常的Activity */ private fun initActivityKiller() { Log.d(TAG, &quot;initActivityKiller: Build.VERSION.SDK_INT=${Build.VERSION.SDK_INT}&quot;) //各版本android的ActivityManager获取方式，finishActivity的参数，token(binder对象)的获取不一样 if (Build.VERSION.SDK_INT &gt;= 28) { sActivityKiller = ActivityKillerV28() } else if (Build.VERSION.SDK_INT &gt;= 26) { sActivityKiller = ActivityKillerV26() } else if (Build.VERSION.SDK_INT == 25 || Build.VERSION.SDK_INT == 24) { sActivityKiller = ActivityKillerV24_V25() } else if (Build.VERSION.SDK_INT in 21..23) { sActivityKiller = ActivityKillerV21_V23() } else if (Build.VERSION.SDK_INT in 15..20) { sActivityKiller = ActivityKillerV15_V20() } else if (Build.VERSION.SDK_INT &lt; 15) { sActivityKiller = ActivityKillerV15_V20() } try { hookMH() Log.e(TAG, &quot;hookMH Success.&quot;) } catch (e: Throwable) { Log.e(TAG, &quot;hookMH 失败: &quot;, e) } } @Throws(Exception::class) private fun hookMH() { Log.d(TAG, &quot;hookMH: &quot;) val LAUNCH_ACTIVITY = 100 val PAUSE_ACTIVITY = 101 val PAUSE_ACTIVITY_FINISHING = 102 val STOP_ACTIVITY_HIDE = 104 val RESUME_ACTIVITY = 107 val DESTROY_ACTIVITY = 109 val NEW_INTENT = 112 val RELAUNCH_ACTIVITY = 126 val activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;) val activityThread = activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;).invoke(null) val mhField: Field = activityThreadClass.getDeclaredField(&quot;mH&quot;) mhField.setAccessible(true) val mhHandler = mhField.get(activityThread) as Handler val callbackField: Field = Handler::class.java.getDeclaredField(&quot;mCallback&quot;) callbackField.setAccessible(true) callbackField.set(mhHandler, Handler.Callback { msg -&gt; if (Build.VERSION.SDK_INT &gt;= 28) { //android P 生命周期全部走这 val EXECUTE_TRANSACTION = 159 if (msg.what === EXECUTE_TRANSACTION) { try { mhHandler.handleMessage(msg) } catch (throwable: Throwable) { sActivityKiller?.finishLaunchActivity(msg) handleLifecycleException(throwable) } return@Callback true } return@Callback false } when (msg.what) { LAUNCH_ACTIVITY -&gt; { try { mhHandler.handleMessage(msg) } catch (throwable: Throwable) { sActivityKiller?.finishLaunchActivity(msg) handleLifecycleException(throwable) } return@Callback true } RESUME_ACTIVITY -&gt; { try { mhHandler.handleMessage(msg) } catch (throwable: Throwable) { sActivityKiller?.finishResumeActivity(msg) handleLifecycleException(throwable) } return@Callback true } PAUSE_ACTIVITY_FINISHING -&gt; { try { mhHandler.handleMessage(msg) } catch (throwable: Throwable) { sActivityKiller?.finishPauseActivity(msg) handleLifecycleException(throwable) } return@Callback true } PAUSE_ACTIVITY -&gt; { try { mhHandler.handleMessage(msg) } catch (throwable: Throwable) { sActivityKiller?.finishPauseActivity(msg) handleLifecycleException(throwable) } return@Callback true } STOP_ACTIVITY_HIDE -&gt; { try { mhHandler.handleMessage(msg) } catch (throwable: Throwable) { sActivityKiller?.finishStopActivity(msg) handleLifecycleException(throwable) } return@Callback true } DESTROY_ACTIVITY -&gt; { try { mhHandler.handleMessage(msg) } catch (throwable: Throwable) { handleLifecycleException(throwable) } return@Callback true } } false }) } /** * 生命周期异常处理 */ private fun handleLifecycleException(e: Throwable) { Log.e(TAG, &quot;lifecycleException: &quot;, e) reportCustomThrowable(Thread.currentThread(), RuntimeException(&quot;Activity生命周期出现异常&quot;, e)) // 给个Toast提示 try { UiUtils.showToastSafe(&quot;小猿刚刚捕获了一只BUG&quot;) } catch (e: Exception) { e.printStackTrace() } } /** * 主线程Looper异常 */ private fun handleLooperException(e: Exception) { // 主线程内发生异常 主动 catch Log.e(TAG, &quot;handleLooperException: &quot;, e) reportCustomThrowable(Thread.currentThread(), e) handleMainThreadException(e) } /** * 本版本不处理 * * view measure layout draw时抛出异常会导致Choreographer挂掉 * 建议直接杀死app。以后的版本会只关闭黑屏的Activity * * @param e */ private fun isChoreographerException(e: Throwable?): Boolean { val elements = e?.stackTrace ?: return false for (i in elements.size - 1 downTo -1 + 1) { if (elements.size - i &gt; 20) { return false } val element = elements[i] if (&quot;android.view.Choreographer&quot; == element.className &amp;&amp; &quot;Choreographer.java&quot; == element.fileName &amp;&amp; &quot;doFrame&quot; == element.methodName) { //View 绘制流程出的问题 return true } } return false } override fun uncaughtException(t: Thread, e: Throwable) { Log.e(TAG, &quot;uncaughtException: &quot;) if (isDebug) { handleDebugException(t, e) } else { handleReleaseException(t, e) } } /** * 处理 Debug 模式的异常 */ private fun handleDebugException(t: Thread, e: Throwable) { Log.e(TAG, &quot;handleDebugException: $t&quot;, e) // 记录本地日志 saveThrowableMessage(Log.getStackTraceString(e)) } /** * 处理 !Debug 模式的异常 */ private fun handleReleaseException(t: Thread, e: Throwable) { Log.e(TAG, &quot;handleReleaseException: $t&quot;, e) // 自定义 Bug 上报 reportCustomThrowable(t, e) // 根据情况来处理异常 if (isMainProcess) { // 为主进程 if (Looper.myLooper() == Looper.getMainLooper()) { // 主线程异常处理 handleMainThreadException(e) } else { // 非主线程 Log.e(TAG, &quot;子线程异常: finish.&quot;) } } else { // 如果是子进程发生异常 直接殺掉子進程 Log.e(TAG, &quot;子进程异常: killProcess.&quot;) android.os.Process.killProcess(android.os.Process.myPid()) } } /** * 主线程异常处理 * * Looper.loop &amp; MainThreadUncaughtException */ private fun handleMainThreadException(e: Throwable) { Log.e(TAG, &quot;handleMainThreadException: &quot;) try { // 主线程 when (e) { is IllegalArgumentException, is IllegalStateException, is IndexOutOfBoundsException, is UnsupportedOperationException, is ArithmeticException, is NumberFormatException, is NullPointerException, is ClassCastException, is AssertionError, is NoSuchElementException -&gt; { Log.e(TAG, &quot;主线程异常: handle finish.&quot;) if (isChoreographerException(e)) { UiUtils.showToastSafe(&quot;界面刷新出了个小问题&quot;) } } else -&gt; { Log.e(TAG, &quot;主线程未知异常：System exit.&quot;) // 这里也可以只给个提示，反正不会程序不会奔溃 android.os.Process.killProcess(android.os.Process.myPid()) System.exit(0) } } } catch (e: Exception) { e.printStackTrace() } } private val logFilePath = Environment.getExternalStorageDirectory().toString() + File.separator + &quot;Example&quot; + File.separator + &quot;CrashLog&quot; private fun saveThrowableMessage(errorMessage: String) { if (TextUtils.isEmpty(errorMessage)) { return } val file = File(logFilePath) if (file.exists() &amp;&amp; file.isDirectory) { // fall through } else { file.mkdirs() } writeToFile(errorMessage, file) } private val formatter: DateFormat = SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;, Locale.CHINA) private fun writeToFile(errorMessage: String, file: File) { ThreadPoolManager.getShortPool()?.execute { var outputStream: FileOutputStream? = null try { val timestamp = System.currentTimeMillis() val time = formatter.format(Date()) val fileName = &quot;crash-$time-$timestamp&quot; val inputStream = ByteArrayInputStream(errorMessage.toByteArray()) outputStream = FileOutputStream(File(file, &quot;$fileName.txt&quot;)) var len: Int val bytes = ByteArray(1024) while (inputStream.read(bytes).also { len = it } != -1) { outputStream.write(bytes, 0, len) } outputStream.flush() Log.e(TAG, &quot;异常奔溃日志成功写入本地文件：${file.absolutePath}&quot;) } catch (e: Exception) { Log.e(TAG, &quot;异常奔溃日志写入本地文件失败: &quot;, e) } finally { if (outputStream != null) { try { outputStream.close() } catch (e: IOException) { // nothing } } } } } /** * 自定义 Bug 上报 */ private fun reportCustomThrowable(t: Thread, e: Throwable) { Log.e(TAG, &quot;reportCustomThrowable: &quot;) try { AliHaAdapter.getInstance().reportCustomError(e) //配置项：自定义错误 } catch (ex: Exception) { Log.e(TAG, &quot;上报自定义异常Error: &quot;, ex) } }} 使用方式： 在 Application 的 onCreate() 方法中, 调用 RrCrashHandler.install(BuildConfig.DEBUG, AppUtils.isMainProgress(this)) 参考链接： https://github.com/android-notes/Cockroach https://github.com/android-notes/Cockroach/blob/master/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.md","link":"/blog/2021/11/19/Android%E4%B8%93%E6%A0%8F-JavaCrash%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86/"},{"title":"Android-JsBridge实现本地H5混合开发","text":"Android JsBridge 混合开发框架0x01 Java 调用 Js我们知道，native层调用h5，在WebView中，如果java要调用js的方法， 0x0101 loadUrl &lt;4.4Android4.4以前使用WebView.loadUrl(&quot;javascript:function()&quot;)。 0x0102 evaluateJavascript &gt;4.4Android4.4以后，使用以下方式 123456webView.evaluateJavascript(&quot;javascript:function()&quot;, new ValueCallback&lt;String&gt;() { @Override public void onReceiveValue(String value) { Toast.makeText(MainActivity.this, &quot;onReceiveValue From JS: &quot; + value, Toast.LENGTH_SHORT).show(); }}); 0x02 Js 调用 Javah5层如何调native，有以下几种形式 0x0201 addJavascriptInterface &gt;4.2在4.2之前有安全隐患，JS可以动态获取到整个底层的实例信息，漏洞已经在Android 4.2上修复了，即使用@JavascriptInterface注解。 0x0202 shouldOverrideUrlLoading拦截自定义scheme0x0203 onJsAlert,onJsConfirm,onJsPromptWebChromeClient对象中有三个方法，分别是onJsAlert,onJsConfirm,onJsPrompt，当js调用window对象的alert，confirm，prompt，WebChromeClient对象中的三个方法对应的就会被触发，进行拦截处理。 推荐使用onJsPrompt，使用频次最少，支持返回值。 1234567891011override fun onJsPrompt( view: WebView?, url: String?, message: String?, defaultValue: String?, result: JsPromptResult?): Boolean { val msg = handleMessage(message) result?.confirm(&quot;Java 处理之后的 Json 数据：$msg&quot;) return true} 0x0204 onConsoleMessage这是Android提供给Js调试在Native代码里面打印日志信息的API，同时这也成了其中一种Js与Native代码通信的方法。在Js代码中调用console.log(‘xxx’)方法。 0x03 自定义通信协议jsbridge://className:callbackId/methodName?json 假设我们需要调用native层的Logger类的log方法，参数是msg，执行完成后js层要有一个回调，那么地址就如下 jsbridge://Logger:callbackId/log?{&quot;msg&quot;:&quot;message from js.&quot;}","link":"/blog/2020/09/19/Android%E4%B8%93%E6%A0%8F-JsBridge%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0H5%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"},{"title":"JsBridge 开源库","text":"JsBridge 开源库项目地址：https://github.com/lzyzsd/JsBridge使用参考：https://www.jianshu.com/p/7aea03838f19 0x00 从H5界面，跳转Native登录，登录之后重新加载H5页面出现JsBridge注入失败[code=-2,message=net::ERR_NAME_NOT_RESOLVED]解决方案：App层销毁当前的WebView，重新加载一个新的WebView去loadUrl。 1234567891011121314// js-bridge register error// 回调 onReceivedError(WebView view, WebResourceRequest request, WebResourceError error)// [code=-2,message=net::ERR_NAME_NOT_RESOLVED]// so you have to destroy webView and rebuild one.private void reloadWebView() { if (mWebView != null) { mWebView.destroy(); mWebView = null; } initView(); initWebView(); webView.loadUrl(url);}","link":"/blog/2022/06/08/Android%E4%B8%93%E6%A0%8F-JsBridge%E5%BC%80%E6%BA%90%E5%BA%93/"},{"title":"Android专栏-SmartRefreshLayout","text":"Android专栏-SmartRefreshLayout0x01 加载结束之后底部多出一段空白位置SmartRefreshLayout 嵌套 ViewPager2 上拉加载更多，在 finishLoadMore() 方法之后，底部加载 Loading 位置会多出一段空白不消失。 解决方案： 1smartRefreshLayout.setEnableScrollContentWhenLoaded(false) 0x02 下拉刷新+PAG动画自定义下拉刷新头部，使用 PAGView 做动画，可以在 onMoving(boolean b, float v, int i, int i1, int i2) 方法中设置 pagView.setProgress(v); 添加手势动画。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import android.content.Context;import android.util.AttributeSet;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.RelativeLayout;import android.widget.TextView;import androidx.annotation.ColorInt;import androidx.annotation.NonNull;import com.scwang.smartrefresh.layout.api.RefreshHeader;import com.scwang.smartrefresh.layout.api.RefreshKernel;import com.scwang.smartrefresh.layout.api.RefreshLayout;import com.scwang.smartrefresh.layout.constant.RefreshState;import com.scwang.smartrefresh.layout.constant.SpinnerStyle;import org.libpag.PAGFile;import org.libpag.PAGView;public class CommonRefreshHeader extends RelativeLayout implements RefreshHeader { public static final String DEFAULT_LOADING_FILE = &quot;load_bubble.pag&quot;; protected View mView; protected ImageView sdv_background; private int mFinishDuration = 300; private ViewGroup rootLayout; private PAGView pagView; private TextView toastTv; public CommonRefreshHeader(Context context) { super(context); initView(context); } public CommonRefreshHeader(Context context, AttributeSet attrs) { super(context, attrs); initView(context); } public CommonRefreshHeader(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initView(context); } public int getLayoutId() { return R.layout.layout_refresh_head; } protected void initView(Context context) { mView = LayoutInflater.from(context).inflate(getLayoutId(), this); toastTv = mView.findViewById(R.id.tv_toast); rootLayout = mView.findViewById(R.id.rootLayout); sdv_background = mView.findViewById(R.id.sdv_background); PAGFile file = PAGFile.Load(context.getAssets(), DEFAULT_LOADING_FILE); pagView = new PAGView(getContext()); LayoutParams params = new LayoutParams(UiUtils.dip2px(39), UiUtils.dip2px(39)); params.addRule(RelativeLayout.CENTER_IN_PARENT); pagView.setLayoutParams(params); pagView.setFile(file); pagView.setRepeatCount(0); rootLayout.addView(pagView); } public void setMarginTop(int marginTop) { if (mView == null) return; ViewGroup root = mView.findViewById(R.id.rootLayout); if (root != null &amp;&amp; root.getLayoutParams() instanceof MarginLayoutParams) { MarginLayoutParams params = (MarginLayoutParams) root.getLayoutParams(); params.topMargin = marginTop; root.setLayoutParams(params); } } @NonNull @Override public View getView() { return mView; } @Override public SpinnerStyle getSpinnerStyle() { return SpinnerStyle.Translate; } @Override public void setPrimaryColors(@ColorInt int... colors) { } @Override public void onInitialized(@NonNull RefreshKernel kernel, int height, int maxDragHeight) { } @Override public void onMoving(boolean b, float v, int i, int i1, int i2) { /** * 【仅限框架内调用】手指拖动下拉（会连续多次调用，添加isDragging并取代之前的onPulling、onReleasing） * @param isDragging true 手指正在拖动 false 回弹动画 * @param percent 下拉的百分比 值 = offset/footerHeight (0 - percent - (footerHeight+maxDragHeight) / footerHeight ) * @param offset 下拉的像素偏移量 0 - offset - (footerHeight+maxDragHeight) * @param height 高度 HeaderHeight or FooterHeight (offset 可以超过 height 此时 percent 大于 1) * @param maxDragHeight 最大拖动高度 offset 可以超过 height 参数 但是不会超过 maxDragHeight */ if (pagView != null &amp;&amp; !pagView.isPlaying()) { pagView.setProgress(v); pagView.flush(); } } @Override public void onReleased(@NonNull RefreshLayout refreshLayout, int i, int i1) { } @Override public void onHorizontalDrag(float percentX, int offsetX, int offsetMax) { } @Override public void onStartAnimator(RefreshLayout layout, int height, int extendHeight) { LogUtils.e(&quot;RefreshHeader&quot;, &quot;onStartAnimator&quot;); if (pagView != null) pagView.play(); } @Override public int onFinish(RefreshLayout layout, boolean success) { LogUtils.e(&quot;RefreshHeader&quot;, &quot;onFinish&quot;); if (pagView != null) pagView.stop(); return mFinishDuration;//延迟500毫秒之后再弹回 } @Override public boolean isSupportHorizontalDrag() { return false; } @Override public void onStateChanged(RefreshLayout refreshLayout, RefreshState oldState, RefreshState newState) { switch (newState) { case None: case PullDownToRefresh: case Refreshing: if (pagView != null) pagView.setVisibility(VISIBLE); if (toastTv != null) toastTv.setVisibility(GONE); break; case ReleaseToRefresh: break; case RefreshFinish: if (pagView != null) pagView.setVisibility(GONE); if (toastTv != null) toastTv.setVisibility(VISIBLE); break; } } public void setToastText(String str) { if (StringUtils.isEmpty(str)) return; if (toastTv != null) { toastTv.setText(str); } } public void setFinishDuration(int finishDuration) { this.mFinishDuration = finishDuration; }}","link":"/blog/2021/09/26/Android%E4%B8%93%E6%A0%8F-SmartRefreshLayout/"},{"title":"Android专栏-WebView","text":"Android专栏-WebView0x00 常规WebViewActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231package com.dench.webviewlibimport android.annotation.SuppressLintimport android.graphics.Bitmapimport android.net.http.SslErrorimport android.os.Buildimport android.os.Bundleimport android.text.TextUtilsimport android.util.Logimport android.view.Gravityimport android.webkit.*import android.widget.TextViewimport android.widget.Toastimport androidx.appcompat.app.AppCompatActivityimport androidx.databinding.DataBindingUtilimport com.alibaba.android.arouter.facade.annotation.Autowiredimport com.alibaba.android.arouter.facade.annotation.Routeimport com.alibaba.android.arouter.launcher.ARouterimport com.dench.baselib.provider.WebViewServiceimport com.dench.baselib.utlis.StatusBarHelperimport com.dench.webviewlib.bridge.JsInterfaceimport com.dench.webviewlib.databinding.ActivityWebViewBindingimport kotlinx.android.synthetic.main.activity_web_view.*@Route(path = WebViewService.activityPath)class WebViewActivity : AppCompatActivity() { @Autowired lateinit var title: String @Autowired lateinit var url: String private lateinit var dataViewBinding: ActivityWebViewBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ARouter.getInstance().inject(this) StatusBarHelper.fitSystemBar(this, false) dataViewBinding = DataBindingUtil.setContentView(this, R.layout.activity_web_view) initToolbar() initWebView() } override fun onBackPressed() { if (webView.canGoBack()) { webView.goBack() return } super.onBackPressed() } private fun initToolbar() { dataViewBinding.toolbar.titleTv.text = title val backIv = dataViewBinding.toolbar.leftIv backIv.setImageResource(R.drawable.ic_close) backIv.setOnClickListener {// 关闭 finish() } } @SuppressLint(&quot;JavascriptInterface&quot;) private fun initWebView() { // webView Settings initWebViewSetting() // init Client initClient() // add Javascript Interface webView.addJavascriptInterface(JsInterface(this), JsInterface.NAME) // register Scroll Listener registerScrollListener() loadUrl() } // webView Settings @SuppressLint(&quot;SetJavaScriptEnabled&quot;) private fun initWebViewSetting() { //声明WebSettings子类 val webSettings = webView.settings //如果访问的页面中要与Javascript交互，则webView必须设置支持Javascript webSettings.javaScriptEnabled = true webSettings.javaScriptCanOpenWindowsAutomatically = true //支持通过JS打开新窗口 //设置自适应屏幕，两者合用 webSettings.useWideViewPort = true //将图片调整到适合webView的大小 webSettings.loadWithOverviewMode = true // 缩放至屏幕的大小 //缩放操作 webSettings.setSupportZoom(true)//支持缩放，默认为true。是下面那个的前提。 webSettings.builtInZoomControls = true //设置内置的缩放控件。若为false，则该WebView不可缩放 webSettings.displayZoomControls = false //隐藏原生的缩放控件 // 缓存 webSettings.cacheMode = WebSettings.LOAD_DEFAULT //webView缓存策略 webSettings.domStorageEnabled = true webSettings.databaseEnabled = true webSettings.setAppCacheEnabled(true) //其他 webSettings.allowFileAccess = true //设置可以访问文件 webSettings.loadsImagesAutomatically = true //支持自动加载图片 webSettings.defaultTextEncodingName = &quot;utf-8&quot; //设置编码格式 // 在安卓5.0之后，默认不允许加载http与https混合内容，需要手动设置 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { webSettings.mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW } } // init Client private fun initClient() { webView.webViewClient = object : WebViewClient() { // 在网页上的所有加载都经过这个方法 override fun shouldOverrideUrlLoading( view: WebView?, request: WebResourceRequest? ): Boolean { Log.i(_tag, &quot;shouldOverrideUrlLoading()&quot;) request?.url?.let { return when (it.scheme) { &quot;http&quot;, &quot;https&quot; -&gt; { // 加载网络html super.shouldOverrideUrlLoading(view, request) } &quot;file&quot;, &quot;content&quot; -&gt; { // 加载本地html super.shouldOverrideUrlLoading(view, request) } else -&gt; { // 特殊 scheme 不处理 showToast(&quot;$it&quot;) true } } } return true } // 加载页面的服务器出现错误时（如404）调用 override fun onReceivedError( view: WebView?, request: WebResourceRequest?, error: WebResourceError? ) { Log.i(_tag, &quot;onReceivedError()&quot;) super.onReceivedError(view, request, error) } // ssl 证书错误 override fun onReceivedSslError( view: WebView?, handler: SslErrorHandler?, error: SslError? ) { Log.i(_tag, &quot;onReceivedSslError()&quot;) handler?.proceed() //表示等待证书响应 // handler?.cancel() //表示挂起连接，为默认方式 // handler?.handleMessage(null) //可做其他处理 } // 开始载入页面调用的。我们可以设定一个loading的页面，告诉用户程序在等待网络响应 override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) { Log.i(_tag, &quot;onPageStarted()&quot;) Log.d( _tag, &quot;onPageStarted() called with: view = $view, url = $url, favicon = $favicon&quot; ) super.onPageStarted(view, url, favicon) webViewProgress.show() } // 在页面加载结束时调用。我们可以关闭loading 条，切换程序动作 override fun onPageFinished(view: WebView?, url: String?) { Log.i(_tag, &quot;onPageFinished()&quot;) super.onPageFinished(view, url) webViewProgress.hide() } // 在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次 override fun onLoadResource(view: WebView?, url: String?) { Log.d(_tag, &quot;onLoadResource()&quot;) Log.d(_tag, &quot;onLoadResource() called with: view = $view, url = $url&quot;) super.onLoadResource(view, url) } } webView.webChromeClient = object : WebChromeClient() { // 加载进度 override fun onProgressChanged(view: WebView?, newProgress: Int) { webViewProgress.progress = newProgress } // Title override fun onReceivedTitle(view: WebView?, title: String?) { if (!TextUtils.isEmpty(title)) { findViewById&lt;TextView&gt;(R.id.titleTv).text = title } } } } // 加载URL private fun loadUrl() { //方式1. 加载一个网页 webView.loadUrl(url) // //方式2：加载apk包中的html页面 // webView.loadUrl(&quot;file:///android_asset/test.html&quot;) // //方式3：加载手机本地的html页面 // webView.loadUrl(&quot;content://com.android.htmlfileprovider/sdcard/test.html&quot;) } // 注册监听 private fun registerScrollListener() { // if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { // webView.setOnScrollChangeListener { _, _, scrollY, _, oldScrollY -&gt; // Log.d(_tag, &quot;scrollY: $scrollY, oldScrollY: $oldScrollY&quot;) // } // } } private val _tag = &quot;WebViewActivity&quot; private fun showToast(info: String?) { val toast = Toast.makeText(this, info, Toast.LENGTH_SHORT) toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0) toast.show() }} 0x01 白屏问题情景一：如果访问的页面中要与Javascript交互，则webView必须设置支持Javascript 1234val webSettings = webView.settings//如果访问的页面中要与Javascript交互，则webView必须设置支持JavascriptwebSettings.javaScriptEnabled = truewebSettings.javaScriptCanOpenWindowsAutomatically = true //支持通过JS打开新窗口 情景二：在安卓5.0之后，默认不允许加载http与https混合内容，需要手动设置 1234// 在安卓5.0之后，默认不允许加载http与https混合内容，需要手动设置if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { webSettings.mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW} 其他情景： 设置domStorageEnabled 和背景色需要验证，暂时没遇到。 0x02 卡顿问题由于设置了 android:layerType=&quot;software&quot;导致的 webview 卡顿。 关于三个layerType属性介绍：https://blog.csdn.net/a345017062/article/details/7478667 解决： 开启 Activity 硬件加速 ``android:hardwareAccelerated=”true”, 并且设置 webview 的android:layerType=”none”`。","link":"/blog/2020/12/26/Android%E4%B8%93%E6%A0%8F-WebView/"},{"title":"adb常用指令","text":"adb常用指令指引官网下载： http://adbshell.com/downloads 命令参考： http://adbshell.com/commands Android官网adb介绍： https://developer.android.google.cn/studio/command-line/adb?hl=zh_cn Mumu adb常用指令指引： https://mumu.163.com/help/20210513/35047_947512.html 0x01 查询和连接设备12345678910## 连接/断开连接网络电视adb connect 170.2.10.20adb disconnect 170.2.10.20## 连接/断开本地模拟器端口adb connect 127.0.0.1:7555adb disconnect 127.0.0.1:7555## 查询已连接设备列表adb devices -l 0x02 adb服务器在某些情况下，您可能需要终止 adb 服务器进程，然后重启才能解决问题。例如，如果 adb 不响应命令，就可能会发生这种情况。 12345678## 停止adb服务adb kill-server## 启动adb服务adb start-server## 以root权限重启adb服务(需要可root设备)adb root 0x03 指定设备操作命令格式：adb -s &lt;serialNumber&gt; command，如：adb -s 127.0.0.1:7555 shell pm list package可以通过 adb devices 获取目标设备的serialNumber 123456$ adb devicesList of devices attachedemulator-5554 deviceemulator-5555 device$ adb -s emulator-5555 install helloWorld.apk 0x04 安装与卸载apk12345## 安装apkadb install C:\\\\xx.apk## 卸载apkadb uninstall C:\\\\xx.apk 0x05 已安装应用列表所有应用包名列表 adb shell pm list packages 第三方应用包名列表 adb shell pm list packages -3 系统应用包名列表 adb shell pm list packages -s 根据某个关键字查找包 adb shell pm list packages |grep tencent 查看包安装位置 adb shell pm list packages -f |grep tencent 0x06 获取设备当前显示应用的包名和Activity123456789101112## 正在运行应用包名和Activity$ adb shell dumpsys window | findstr mCurrentFocusmCurrentFocus=nullmCurrentFocus=Window{fe571d0 u0 com.zhongduomei.rrmj.society/com.rrtv.rrtvtrunk.main.presentation.MainActivity}## 设备当前显示应用的包名和Activity名称$ adb shell dumpsys window w |findstr \\/ |findstr name=mSurface=Surface(name=NavigationBar0)/@0xe825312mSurface=Surface(name=StatusBar)/@0x2a132d5mSurface=Surface(name=com.tencent.qqlive/com.tencent.qqlive.ona.activity.SplashHomeActivity)/@0xc6af35bmSurface=Surface(name=com.android.systemui.ImageWallpaper)/@0x65b6a37 0x07 启动应用adb shell am start -n 应用包名/应用Activity类名 若想查看启动应用耗时，则可使用adb shell am start -W 应用包名/应用Activity类名 0x08 关闭应用adb shell am force-stop 应用包名 0x09 查看应用版本号adb shell dumpsys package 应用包名 | findstr version 0x10 清理应用数据adb shell pm clear 应用包名 0x11 模拟输入按键输入 adb shell input keyevent 键值 如：adb shell input keyevent 3表示按下HOME键，其他键值对应键位可网上搜索 字符输入 adb shell input text 字符 如：adb shell input text test则表示输入了test字符串 ps：字符不支持中文 鼠标点击 adb shell input tap X Y X Y分别为当前屏幕下的x和y轴坐标值 鼠标滑动 adb shell input swipe X1 Y1 X2 Y2 X1 Y1 和X2 Y2分别为滑动起始点的坐标 0x12 从电脑上传文件至模拟器adb push myfile.txt /sdcard/myfile.txt 0x13 从模拟器复制文件至电脑adb pull /data/test.apk D:\\ 0x14 截图将模拟器当前显示截图 adb shell screencap /data/screen.png 将截图文件下载至电脑 adb pull /data/screen.png C:\\ 0x15 录制视频开始录制 adb shell screenrecord /data/test.mp4 结束录制 可按CTRL+C结束录制 导出视频文件 adb pull /data/test.mp4 C:\\ 0x16 查看设备信息123456789101112131415161718192021222324## 设备型号$ adb shell getprop ro.product.model## 设备品牌$ adb shell getprop ro.product.brand## 设备处理器型号$ adb shell getprop ro.product.board## 设备安卓版本号$ adb shell getprop ro.build.version.release## 设备abi$ adb shell getprop ro.product.cpu.abi## 设备cpu信息$ adb shell cat /proc/cupinfo## 设备引擎渲染模式$ adb shell dumpsys SurfaceFlinger|findstr &quot;GLES&quot; ## grep product关键字（设备支持的abi列表） $ adb shell getprop |grep product 0x17 管理设备 命令 功能 adb get-state 判断设备状态 adb devices 显示连接到计算机的设备 adb get-serialno 获取设备的序列号 adb reboot 重启设备 adb reboot bootloader 重启设备进入fastboot模式 adb reboot recovery 重启设备进入recovery模式","link":"/blog/2021/11/25/Android%E4%B8%93%E6%A0%8F-adb/"},{"title":"Apk签名","text":"Apk签名0x01 生成签名文件1keytool -genkey -alias **** -keypass **** -keyalg RSA -keysize 1024 -validity 3650 -keystore D:\\****.jks -dest D:\\****.jks -storetype pkcs12 -storepass **** 0x02 查看签名文件md51keytool -v -list -keystore ****.jks -storepass **** 如果还是看不到md5值，在 AndroidStudio 中执行gradlew命令 1gradlew signingReport","link":"/blog/2021/11/23/Android%E4%B8%93%E6%A0%8F-apk%E7%AD%BE%E5%90%8D/"},{"title":"微信AndResGuard资源混淆工具","text":"微信AndResGuard资源混淆工具AndResGuard是一个帮助你缩小APK大小的工具，他的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a。 AndResGuard不涉及编译过程，只需输入一个apk(无论签名与否，debug版，release版均可，在处理过程中会直接将原签名删除)，可得到一个实现资源混淆后的apk(若在配置文件中输入签名信息，可自动重签名并对齐，得到可直接发布的apk)以及对应资源ID的mapping文件。 原理介绍根据Android的编译流程，所有资源ID已经被编译成32位int值。这说明我们并不需要去修改xml与java，因为在编译过程已经被R.java所替换，我们直接修改resources.arsc的二进制数据，不改变打包流程，只要在生成resources.arsc之后修改它，同时重命名资源文件。 使用场景 缩小APK体积 保护res资源文件的可读性 皮应用中减少跟主应用代码的重复率 使用说明项目根目录下build.gradle中，添加插件的依赖： 123456789buildscript { repositories { jcenter() google() } dependencies { classpath 'com.tencent.mm:AndResGuard-gradle-plugin:1.2.21' }} app模块下的build.gradle中添加相关配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849apply plugin: 'AndResGuard'andResGuard { // mappingFile = file(&quot;./resource_mapping.txt&quot;) mappingFile = null use7zip = true useSign = true // 打开这个开关，会keep住所有资源的原始路径，只混淆资源的名字 keepRoot = false // 设置这个值，会把arsc name列混淆成相同的名字，减少string常量池的大小 fixedResName = &quot;arg&quot; // 打开这个开关会合并所有哈希值相同的资源，但请不要过度依赖这个功能去除去冗余资源 mergeDuplicatedRes = true whiteList = [ // for your icon &quot;R.drawable.icon&quot;, // for fabric &quot;R.string.com.crashlytics.*&quot;, // for google-services &quot;R.string.google_app_id&quot;, &quot;R.string.gcm_defaultSenderId&quot;, &quot;R.string.default_web_client_id&quot;, &quot;R.string.ga_trackingId&quot;, &quot;R.string.firebase_database_url&quot;, &quot;R.string.google_api_key&quot;, &quot;R.string.google_crash_reporting_api_key&quot; ] compressFilePattern = [ &quot;*.png&quot;, &quot;*.jpg&quot;, &quot;*.jpeg&quot;, &quot;*.gif&quot;, ] sevenzip { artifact = 'com.tencent.mm:SevenZip:1.2.21' //path = &quot;/usr/local/bin/7za&quot; } /** * 可选： 如果不设置则会默认覆盖assemble输出的apk **/ // finalApkBackupPath = &quot;${project.rootDir}/final.apk&quot; /** * 可选: 指定v1签名时生成jar文件的摘要算法 * 默认值为“SHA-1” **/ // digestalg = &quot;SHA-256&quot;} 如何启动使用Android Studio的同学可以再 andresguard 下找到相关的构建任务; 命令行可直接运行./gradlew resguard[BuildType | Flavor]， 这里的任务命令规则和assemble一致。 配置7Zip在设置sevenzip时, 你只需设置artifact或path. 支持同时设置,总以path的值为优先. 结果如果没有配置finalApkBackupPath，最终结果会覆盖assemble[BuildType | Flavor]的输出APK。如果配置则输出至finalApkBackupPath配置路径。 一些需要注意的问题 如果不是对APK size有极致的需求，请不要把resources.arsc添加进compressFilePattern. 对于发布于Google Play的APP，建议不要使用7Zip压缩，因为这个会导致Google Play的优化Patch算法失效. compress参数对混淆效果的影响若指定compess 参数.png、.gif以及*.jpg，resources.arsc会大大减少安装包体积。若要支持2.2，resources.arsc需保证压缩前小于1M。 操作系统对7z的影响实验证明，linux与mac的7z效果更好 keepmapping方式对增量包大小的影响影响并不大，但使用keepmapping方式有利于保持所有版本混淆的一致性 渠道包的问题(建议通过修改zip摘要的方式生产渠道包)在出渠道包的时候，解压重压缩会破坏7zip的效果，通过repackage命令可用7zip重压缩。 通过getIdentifier方式获得资源，需要放置白名单中。 部分手机桌面快捷图标的实现有问题，务必将程序桌面icon加入白名单 第三方SDK的资源加入白名单。可以在white_list.mdhttps://github.com/shwenzhang/AndResGuard/blob/master/doc/white_list.md查看更多sdk的白名单配置 Glide加载本地资源需要加入白名单。 相关资源使用说明：https://github.com/shwenzhang/AndResGuard/blob/master/README.zh-cn.md 原理介绍：https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd white_list.md：https://github.com/shwenzhang/AndResGuard/blob/master/doc/white_list.md","link":"/blog/2022/11/26/Android%E4%B8%93%E6%A0%8F-%E5%BE%AE%E4%BF%A1AndResGuard%E8%B5%84%E6%BA%90%E6%B7%B7%E6%B7%86%E5%B7%A5%E5%85%B7/"},{"title":"自定义Notification遇到的坑","text":"自定义Notification 实现： 123456789101112131415161718192021222324252627282930313233343536373839// RemoteViews for notificationprivate var rv: RemoteViews? = nullprivate var rvExpanded: RemoteViews? = nullprivate fun customNotification(process: Int) { // custom RemoteViews if (rv == null) rv = RemoteViews(packageName, R.layout.notification_small) rv?.setTextViewText(R.id.notification_title, &quot;这是一个小标题&quot;) if (rvExpanded == null) rvExpanded = RemoteViews(packageName, R.layout.notification_large) rvExpanded?.setTextViewText(R.id.large_notification_title, &quot;这是一个大标题，支持很多的内容: $process%&quot;) // PendingIntent val intentNotification = Intent(this, PlayMusicActivity::class.java).apply { flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP } val pendIntent = PendingIntent.getActivity( this, 0, intentNotification, PendingIntent.FLAG_UPDATE_CURRENT ) // build notification val customNotification = NotificationCompat.Builder(applicationContext, CHANNEL_ID) .setSmallIcon(R.drawable.bravo) // small Icon .setStyle(NotificationCompat.DecoratedCustomViewStyle()) // 自定义contentView .setCustomContentView(rv!!) .setContent(rvExpanded!!) .setCustomBigContentView(rvExpanded!!) .setCustomHeadsUpContentView(rvExpanded!!) .setOngoing(true) // 一直显示 .setAutoCancel(false) // 点击后消失 .setVisibility(NotificationCompat.VISIBILITY_PUBLIC) // 锁屏显示,需要配合权限设置 .setPriority(NotificationCompat.PRIORITY_HIGH) // Priority .setOnlyAlertOnce(true) // 声音，震动，仅弹出一次 .setContentIntent(pendIntent) .build() startForeground(NOTIFICATION_ID, customNotification)} 1.使用 NotificationCompat 兼容各个版本差异性 2.RemoteViews 布局文件不支持 constraintlayout ，切记 3.在SDK 26之后必须要绑定Channel，所以通知要先创建Channel 123456789101112131415161718192021222324252627282930fun checkAndCreateChannel( context: Context, channelId: String, channelName: String, desc: String = channelName) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { val notificationManager: NotificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager try { // 查找分组 val nc = notificationManager.getNotificationChannel(channelId) Log.d(&quot;ChannelHelper&quot;, &quot;${nc.id} Notification Channel exist.&quot;) } catch (e: Exception) { Log.d(&quot;ChannelHelper&quot;, &quot;empty channel need create.&quot;) // 创建分组 val mChannel = NotificationChannel( channelId, channelName, NotificationManager.IMPORTANCE_HIGH ).apply { description = desc enableLights(true) enableVibration(true) } notificationManager.createNotificationChannel(mChannel) } }}","link":"/blog/2020/09/23/Android%E4%B8%93%E6%A0%8F-%E9%80%9A%E7%9F%A5%E6%A0%8FNotification/"},{"title":"Android之FileProvider详解","text":"Android之FileProvider详解原文地址：https://juejin.cn/post/7009204672225345549 Android 7.0之前，文件的Uri以 file:///形式提供给其他app访问。 Android 7.0之后，分享文件的Uri发生了变化。为了安全起见， file:///形式的Uri不能正常访问。官方提供了 FileProvider，FileProvider生成的Uri会以 content://的形式分享给其他app使用。 在7.0以前，为了访问 file:///形式的Uri，我们必须修改文件的权限。修改后的权限对所有app都是有效的，这样的行为是不安全的。 content://形式的Uri让Android的文件系统更安全，对于分享的文件，接收方app只拥有临时的权限，减少了我们app内部的文件被其他app恶意操作的行为。 0x01 创建FileProvider在manifest文件 &lt;application&gt;&lt;/application&gt;标签中添加pvodier标签，配置如下。 12345678910111213&lt;manifest&gt; &lt;application&gt; &lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;${applicationId}.FileProvider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; android:name指定Provider的类名，使用官方提供的androidx.core.content.FileProvider。 android:authorities相当于一个用于认证的暗号，在分享文件生成Uri时，会通过它的值生成对应的Uri。。值是一个域名，一般格式为 &lt;包名&gt;.fileprovider&lt;/包名&gt;。 android:exported设置为false，FileProvider不需要公开。 android:grantUriPermissions设置为true，这样就能授权接收端的app临时访问权限了。 0x02 配置共享目录file_paths.xml在res/xml中创建一个资源文件（如果xml目录不存在，先创建），名字随便（一般叫file_paths.xml）。 1234&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;files-path name=&quot;my_logs&quot; path=&quot;logs/&quot;/&gt; ...&lt;/paths&gt; &lt;paths&gt;&lt;/paths&gt;必须有1个或多个子标签，每个子标签代表要请求的私有文件目录。不同的子标签代表不同的目录类型。 在 &lt;provider&gt;&lt;/provider&gt;标签中添加 &lt;meta-data&gt;&lt;/meta-data&gt;子标签。 设置 &lt;meta-data&gt;&lt;/meta-data&gt;的属性 android:name值为 android.support.FILE_PROVIDER_PATHS,属性 android:resouce的值为刚才我们创建的path文件名。 配置paths&lt;paths&gt;&lt;/paths&gt;的每个子标签必须有 path属性，代表content Uris的路径。 name不需要和path保持一样，只是一个名称。 子标签有以下几种。 files-path12&lt;files-path name=&quot;my_files&quot; path=&quot;path&quot; /&gt; 代表内部存储的files目录，与 Context.getFilesDir()获取的路径对应。 最终生成的Uri格式为：authorities/pathname/filename 示例： 12content: cache-path12&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 代表内部存储的cache目录，与 Context.getCacheDir()获取的路径对应。 external-path12&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 代表外部存储(sdcard)的cache目录，与 Environment.getExternalStorageDirectory()获取的路径对应。 external-files-path12&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 代表app的外部存储的根目录，与 Context#getExternalFilesDir(String) Context.getExternalFilesDir(null)获取的路径对应。 external-cache-path12&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 代表app外部缓存区域的根目录，与 Context.getExternalCacheDir()获取的路径对应。 external-media-path12&lt;external-media-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 代表app外部存储媒体区域的根目录，与 Context.getExternalMediaDirs()获取的路径对应。 注意： 这个目录只在API 21（也就是Android 5.0）以上的系统上才存在。 0x03 生成Content Uri文件为了让其他app使用Content Uri，我们的app必须提前生成Uri。 1234567File file = new File(Context.getFilesDir(), &quot;my_log&quot;);Uri uri;if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { uri = FileProvider.getUriForFile(getContext(), this.getPackageName() + &quot;.FileProvider&quot;, file);} else { uri = Uri.fromFile(file);} 这里注意获取目录，在配置paths时我们讲了，paths的子标签必须和获取目录的代码保持对应。这里我们用的是 Context.getFilesDir(),所以paths文件中必须包含 files-path子标签，不然别的app获取uri时会出现异常。 最终生成Uri是使用的 FileProvider.getUriForFile()。第一个参数就是 provider中设置的 authorities属性值。 0x04 Content Uri的几种使用场景为邮箱app分享附件文件1intent.putExtra(Intent.EXTRA_STREAM, contentUri); 其他分享使用 Intent.setDate或 Intent.setClipData()。 1intent.setClipDataClipData.newRawUri(&quot;&quot;, contentUri) 最后使用 startActivity(intent)启动分享操作。 0x05 授权临时权限分享一般只有这读取和写入2种权限，根据需要传入 Intent.addFlags()中。 12Intent intent = new Intent(Intent.ACTION_SEND);intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);","link":"/blog/2023/08/07/Android%E4%B9%8BFileProvider%E8%AF%A6%E8%A7%A3/"},{"title":"Android从现有的项目创建一个皮应用","text":"Android从现有的项目创建一个皮应用0x01 Copy一个新项目 clean原项目，然后直接Copy原项目所有文件，等待完成 根据新项目重命名新文件夹名称 删除原项目的 .idea .git .gitlab 等文件夹，.gradle 可以不删 用编辑器打开 settings.gradle，修改项目名称 rootProject.name = &quot;xxx&quot; 0x02 重命名项目包名这一步是要将包名从 com.sample1.android 重命名为 com.sample2.android 用AndroidStudio打开新项目，去掉 Compat Middle Packages 前面的勾 选择项目的 sample1 包名，Shift + F6重命名 一定选择 Rename Package 等待完成，项目大时间就比较长 修改 .aidl 文件的包名路径和import的路径 修改根目录下的 build.gradle 的 applicationId &quot;com.sample2.android&quot;，并 sync ps: 不清楚为啥Kotlin的扩展函数还需要重新手动导入 0x03 推到代码库到上面这一步，不出意外的话已经可以编译成功并且跑起来了。编译成功之后可以先推送本地项目到代码库。 远程代码库新建项目，获取新项目git地址，然后执行下面操作。 123456$ cd existing_folder$ git init$ git remote add origin git://github.com/schacon/grit.git$ git add .$ git commit$ git push -u origin master 0x04 后续下面就是修改名称，URL，替换功能啥的。 Logo、名称、资源文件替换 H5协议替换 域名修改 第三方账号切换 0x05 审核相关现在应用市场对新应用的审核非常严格。为了过审，可能需要做很多相关的工作 混淆，或者改文件名 资源混淆，或者资源改名 增加新功能 修改UI界面样式 做审核版功能 0x06 问题0x0601 如果Shift + F6重命名时没有Rename Package选项如果Shift + F6重命名时没有Rename Package选项, 并且出现了以下提示，Package 'example' contains directories in libraries which cannot be renamed. Do you want to rename current directory or all directories in project?，这是因为依赖包中也存在example这个包名，导致无法直接重命名包名。解决的方案分两种： 方案1. 暂时先移除包含example包名的依赖包，等重命名之后重新添加到项目中方案2. 只能新建package，然后将要rename的包拖动到新的package中，或者F6移动 PS：因为无法重命名，刚刚经历了手动移动十几个module的package包路径的痛苦历程。","link":"/blog/2022/09/08/Android%E4%BB%8E%E7%8E%B0%E6%9C%89%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9A%AE%E5%BA%94%E7%94%A8/"},{"title":"Android 分享功能","text":"Android 分享功能友盟分享SDKhttps://developer.umeng.com/docs 友盟分享，QQ和QQ空间分享成功了，却总是回调分享取消qqzone_id_value 配置跟当前应用对应不上,PlatformConfig.setQQZone(qqzone_id_value, qqzone_secret_id_value)","link":"/blog/2022/06/23/Android%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD/"},{"title":"Android动态权限申请","text":"Android动态权限申请0x01 介绍由于 Android 动态权限申请是一个交互比较复杂的模块，整个申请的流程也比较长，所以，写了一个工具来封装了一个，也具体的实现了一个流程。 由于每个App的Ui风格不一致，所以没有把Toast和弹框封装进工具，等后期有好的想法再优化。 0x02 动态权限申请流程 检查授权状态 申请权限 处理权限申请结果 当用户‘拒绝且不再询问’，引导去手机设置 检查手机设置后的权限申请结果 0x03 使用说明主要封装类 PermissionManager 根据业务需要用到安卓定义的高危权限，需要去动态申请权权限。通常是在Activity 和 Fragment 组件中发起。 1 检查权限授权状态 123456if (PermissionManager.hasPermissions(this, Manifest.permission.READ_PHONE_STATE)) { // after permission afterPermission()} else { showRequestPermissionDialog(&quot;申请手机权限的原因是因为我需要&quot;, Manifest.permission.READ_PHONE_STATE)} 2 申请权限，根据合规化通常需要先弹框 12345678910111213141516private fun showRequestPermissionDialog(message: String, vararg perm: String) { AlertDialog.Builder(this) .setTitle(&quot;权限申请&quot;) .setMessage(message) .setPositiveButton(&quot;去授权&quot;) { dialog, which -&gt; dialog.dismiss() PermissionManager.requestPermissions(this, *perm) } .setNegativeButton(&quot;取消&quot;) { dialog, which -&gt; dialog.dismiss() ToastUtil.showToast(this, &quot;已取消授权...&quot;) } .setCancelable(false) .create() .show()} 3 处理权限申请结果 在 onRequestPermissionsResult 回调接口中，调用 PermissionManager.onRequestPermissionsResult 方法，并且实现 PermissionManager.OnPermissionResultCallback 这个回调接口。 123456789101112131415161718192021222324252627override fun onRequestPermissionsResult( requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) { super.onRequestPermissionsResult(requestCode, permissions, grantResults) PermissionManager.onRequestPermissionsResult( this, requestCode, permissions, grantResults, this )}override fun onPermissionsGranted(requestCode: Int, perms: List&lt;String?&gt;) { ToastUtil.showToast(this, &quot;授权成功&quot;) afterPermission()}override fun onPermissionsDenied(requestCode: Int, perms: List&lt;String?&gt;) { ToastUtil.showToast(this, &quot;授权失败&quot;)}override fun onPermissionDeniedForever(requestCode: Int, perms: List&lt;String?&gt;) { showSettingsDialog()} 4 当用户‘拒绝且不再询问’，引导去手机设置 123456789101112131415161718private fun showSettingsDialog() { AlertDialog.Builder(this) .setTitle(&quot;权限申请&quot;) .setMessage(&quot;已永久拒绝，需要去设置-&gt;权限设置打开&quot;) .setPositiveButton(&quot;前往设置&quot;) { dialog, which -&gt; dialog.dismiss() val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS) .setData(Uri.fromParts(&quot;package&quot;, packageName, null)) startActivityForResult(intent, REQUEST_CODE_FOR_PERMISSION_SETTINGS) } .setNegativeButton(&quot;取消&quot;) { dialog, which -&gt; dialog.dismiss() ToastUtil.showToast(this, &quot;已取消授权...&quot;) } .setCancelable(false) .create() .show()} 5 检查手机设置后的权限申请结果 1234567override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { if (requestCode == REQUEST_CODE_FOR_PERMISSION_SETTINGS) { afterPermission() } else { super.onActivityResult(requestCode, resultCode, data) }} 0x04 特别推荐 PermissionXPermissionX 中文文档 PermissionX is an extension Android library that makes Android runtime permission request extremely easy. You can use it for basic permission request occasions or handle more complex conditions, like showing rationale dialog or go to app settings for allowance manually.","link":"/blog/2022/10/10/Android%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7@2022/"},{"title":"Android首页灰色实现方案","text":"Activity设置灰色使用ColorMatrix设置灰度 1234567private fun setGrayPaint(view: View) { val paint = Paint() val cm = ColorMatrix() cm.setSaturation(0f) paint.colorFilter = ColorMatrixColorFilter(cm) view.setLayerType(View.LAYER_TYPE_HARDWARE, paint)} 给首页Activity的decorView设置灰度Paint 12345678override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(...) // 需要在 setContentView 之后 setGrayPaint(window.decorView)} 需要特殊处理的控件 弹框 WebView SurfaceView 这些控件由于不是跟activity公用一个window，需要各自单独处理灰度Paint。调用 setGrayPaint(view) 即可。 相关资源Android实现设置灰白模式效果","link":"/blog/2022/12/01/Android%E9%A6%96%E9%A1%B5%E7%81%B0%E8%89%B2%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"title":"BottomFragment","text":"底部弹出控件 - Fragment 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import android.os.Bundleimport android.util.Logimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.fragment.app.Fragmentimport androidx.fragment.app.FragmentManagerimport com.dench.baselib.Rimport com.dench.baselib.databinding.FragmentBottomBindingclass BottomFragment : Fragment() { companion object { fun start(fm: FragmentManager, fragment: Fragment): BottomFragment { val bottomFragment = BottomFragment().apply { setFragment(fragment) } fm.beginTransaction() .setCustomAnimations( R.anim.fragment_bottom_enter, 0, 0, R.anim.fragment_bottom_exit ) .add(android.R.id.content, bottomFragment) .addToBackStack(null) .commitAllowingStateLoss() return bottomFragment } } private lateinit var fragment: Fragment private fun setFragment(fragment: Fragment) { this.fragment = fragment } private lateinit var binding: FragmentBottomBinding private val TAG = &quot;BottomFragment&quot; override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { binding = FragmentBottomBinding.inflate(inflater, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.run { binding.bottomFragmentRl.setOnClickListener(View.OnClickListener { Log.d(TAG, &quot;bottom root view click.&quot;) dismissSelf() }) /** add fragment */ childFragmentManager.beginTransaction() .add(R.id.container, fragment) .commitAllowingStateLoss() } } private fun dismissSelf() { parentFragmentManager.popBackStack() }}","link":"/blog/2021/05/19/BottomFragment/"},{"title":"Chrome Shortcuts(mac)","text":"Shortcuts Action command+N 新的窗口 command+shift+N 新的无痕窗口 command+T 新的标签页 command+option+right 标签页切换（向右） command+option+left 标签页切换（向左） command+W 关闭当前标签页 control+Enter 在地址栏中的内容添加”www.”和”.com”然后打开 command+D 将当前网页加入书签 command+R 刷新 command+Shift+R 刷新（忽略缓存） command 和 + 放大 command 和 - 缩小 command+option+L 打开下载内容 command+option+B 打开书签管理","link":"/blog/2020/02/09/Chrome%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"DataBinding踩坑指南","text":"0x01 ViewBinding1.使用 View Binding 先要在Module 的 build.gradle 文件注册 123456android { ... buildFeatures { viewBinding true }} 2.会根据布局文件，编译之后自动生成对应的Binding class，可以在Activity 和 Fragment 直接调用 inflate 使用 12345678910111213141516171819private var _binding: ResultProfileBinding? = null// This property is only valid between onCreateView and// onDestroyView.private val binding get() = _binding!!override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { _binding = ResultProfileBinding.inflate(inflater, container, false) val view = binding.root return view}override fun onDestroyView() { super.onDestroyView() _binding = null} 0x02 DataBinding1.在 build.gradle 文件中开启lib 123456android { ... buildFeatures { dataBinding true }} 2.布局文件start with a root tag of layout followed by a data element 123456789&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewmodel&quot; type=&quot;com.myapp.data.ViewModel&quot; /&gt; &lt;/data&gt; &lt;ConstraintLayout... /&gt; &lt;!-- UI layout's root element --&gt;&lt;/layout&gt; 3.在Activity中使用 12345678910override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding: ActivityMainBinding = ActivityMainBinding.inflate(getLayoutInflater()) // or val binding: ActivityMainBinding = DataBindingUtil.setContentView( this, R.layout.activity_main) binding.user = User(&quot;Test&quot;, &quot;User&quot;)} 在 Fragment, ListView, or RecyclerView adapter, you may prefer to use the inflate() 123val listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)// orval listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false) 0x03 view binding 和 data binding 比较View binding and data binding both generate binding classes that you can use to reference views directly. However, view binding is intended to handle simpler use cases and provides the following benefits over data binding: Faster compilation: View binding requires no annotation processing, so compile times are faster. Ease of use: View binding does not require specially-tagged XML layout files, so it is faster to adopt in your apps. Once you enable view binding in a module, it applies to all of that module’s layouts automatically. Conversely, view binding has the following limitations compared to data binding: View binding doesn’t support layout variables or layout expressions, so it can’t be used to declare dynamic UI content straight from XML layout files. View binding doesn’t support two-way data binding. Because of these considerations, it is best in some cases to use both view binding and data binding in a project. You can use data binding in layouts that require advanced features and use view binding in layouts that do not. 0x04 遇到的坑 等标签，如果使用databinding ，子布局xml的 root tag 依旧需要layout 标签嵌套 data 标签。否者编译报错，找不到对应的属性","link":"/blog/2020/09/26/DataBinding%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"title":"ExoPlayer简易播放器","text":"ExoPlayer简易播放器一个简单的基于ExoPlayer的播放器。ExoPlayer官网：https://exoplayer.dev/使用ExoPlayer版本：2.18.2 实现功能：通过url播放视频，简易自定义controller，监听播放器状态变化，首帧时间打印，错误信息打印。 如果需要深层次的UI定制，建议不要用exo_ui库下面的布局，用SurfaceView和TextureView完全自定义。具体代码如下: 1.播放器Fragment123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import android.os.Bundleimport android.util.Logimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.fragment.app.Fragmentimport com.google.android.exoplayer2.ExoPlayerimport com.google.android.exoplayer2.MediaItemimport com.google.android.exoplayer2.PlaybackExceptionimport com.google.android.exoplayer2.Playerimport com.google.android.exoplayer2.Player.Listenerimport com.google.android.exoplayer2.ui.StyledPlayerViewclass ExoPlayerFragment : Fragment() { companion object { fun newInstance(url: String): ExoPlayerFragment { val args = Bundle() args.putString(EXO_URI, url) val fragment = ExoPlayerFragment() fragment.arguments = args return fragment } private const val TAG = &quot;ExoPlayerFragment&quot; private const val EXO_URI = &quot;EXO_URI&quot; } private var videoUri: String? = null private var player: ExoPlayer? = null private val listener = object : Listener { override fun onEvents(player: Player, events: Player.Events) { super.onEvents(player, events) Log.d(TAG, &quot;onEvents-&gt;${events}:&quot;) } override fun onPlaybackStateChanged(playbackState: Int) { val stateString: String = when (playbackState) { ExoPlayer.STATE_IDLE -&gt; &quot;ExoPlayer.STATE_IDLE&quot; ExoPlayer.STATE_BUFFERING -&gt; &quot;ExoPlayer.STATE_BUFFERING&quot; ExoPlayer.STATE_READY -&gt; &quot;ExoPlayer.STATE_READY&quot; ExoPlayer.STATE_ENDED -&gt; &quot;ExoPlayer.STATE_ENDED&quot; else -&gt; &quot;UNKNOWN_STATE&quot; } Log.d(TAG, &quot;onPlaybackStateChanged: state=$stateString&quot;) super.onPlaybackStateChanged(playbackState) printPlayerTimeLine(&quot;onPlaybackStateChanged:&quot;) } override fun onRenderedFirstFrame() { super.onRenderedFirstFrame() printPlayerTimeLine(&quot;onRenderedFirstFrame:&quot;) } override fun onPlayerError(error: PlaybackException) { super.onPlayerError(error) printPlayerTimeLine(&quot;onPlayerError:&quot;) error.printStackTrace() } } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { videoUri = arguments?.getString(EXO_URI) val root = inflater.inflate(R.layout.exo_player_fragment, container, false) val playerView = root.findViewById&lt;StyledPlayerView&gt;(R.id.styled_player_view) initPlayerView(playerView) return root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) startPlay() } private fun initPlayerView(playerView: StyledPlayerView) { Log.d(TAG, &quot;initPlayerView: &quot;) player = ExoPlayer.Builder(requireContext()).build() player?.addListener(listener) // Bind the player to the view. playerView.player = player // back playerView.findViewById&lt;View&gt;(R.id.back).setOnClickListener { fragmentManager?.popBackStack() val ft = fragmentManager?.beginTransaction() ft?.remove(this@ExoPlayerFragment) ft?.commitAllowingStateLoss() } } private var prepareTime: Long = 0L private fun printPlayerTimeLine(method: String) { val c = System.currentTimeMillis() val duration = if (prepareTime == 0L) 0 else c - prepareTime prepareTime = c Log.i(TAG, &quot;printPlayerTimeLine: method=$method, duration=$duration, uri=${videoUri}&quot;) } private fun startPlay() { Log.d(TAG, &quot;startPlay: &quot;) videoUri?.let { // Build the media item. val mediaItem: MediaItem = MediaItem.fromUri(it) // Set the media item to be played. player?.setMediaItem(mediaItem) // Prepare the player. player?.prepare() printPlayerTimeLine(&quot;player-&gt;prepare:&quot;) // Start the playback. player?.play()// calPlayerTimeLine(&quot;player-&gt;play:&quot;) } } override fun onDestroy() { player?.release() super.onDestroy() }} 2.播放器布局exo_player_fragment.xml 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/black&quot; android:clickable=&quot;true&quot;&gt; &lt;com.google.android.exoplayer2.ui.StyledPlayerView android:id=&quot;@+id/styled_player_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:keepScreenOn=&quot;true&quot; app:animation_enabled=&quot;false&quot; app:controller_layout_id=&quot;@layout/custom_player_control_view&quot; app:use_controller=&quot;true&quot; /&gt;&lt;/FrameLayout&gt; 3.自定义的controller布局custom_player_control_view.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;bottom&quot; android:background=&quot;#00000000&quot; android:layoutDirection=&quot;ltr&quot; android:orientation=&quot;vertical&quot; tools:targetApi=&quot;28&quot;&gt; &lt;ImageView android:id=&quot;@+id/back&quot; android:layout_width=&quot;42dp&quot; android:layout_height=&quot;42dp&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;16dp&quot; android:background=&quot;#33000000&quot; android:scaleType=&quot;centerInside&quot; android:src=&quot;@mipmap/back&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;LinearLayout android:id=&quot;@id/exo_bottom_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#33000000&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot; android:paddingTop=&quot;4dp&quot; android:paddingBottom=&quot;4dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot;&gt; &lt;ImageButton android:id=&quot;@id/exo_prev&quot; style=&quot;@style/ExoStyledControls.Button.Center.Previous&quot; android:padding=&quot;8dp&quot; /&gt; &lt;ImageButton android:id=&quot;@id/exo_play_pause&quot; style=&quot;@style/ExoStyledControls.Button.Center.PlayPause&quot; android:padding=&quot;8dp&quot; /&gt; &lt;ImageButton android:id=&quot;@id/exo_next&quot; style=&quot;@style/ExoStyledControls.Button.Center.Next&quot; android:padding=&quot;8dp&quot; /&gt; &lt;TextView android:id=&quot;@id/exo_position&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:includeFontPadding=&quot;false&quot; android:paddingLeft=&quot;4dp&quot; android:paddingRight=&quot;4dp&quot; android:textColor=&quot;#FFBEBEBE&quot; android:textSize=&quot;14sp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;com.google.android.exoplayer2.ui.DefaultTimeBar android:id=&quot;@id/exo_progress&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;26dp&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;TextView android:id=&quot;@id/exo_duration&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:includeFontPadding=&quot;false&quot; android:paddingLeft=&quot;4dp&quot; android:paddingRight=&quot;4dp&quot; android:textColor=&quot;#FFBEBEBE&quot; android:textSize=&quot;14sp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;","link":"/blog/2023/03/16/ExoPlayer%E7%AE%80%E6%98%93%E6%92%AD%E6%94%BE%E5%99%A8/"},{"title":"Git手册","text":"Git Hand BookGit 官方站点: http://git-scm.com/download 0x01 全局信息设置123456$ git config --global http.sslVerify false # 取消ssl认证## 用户名和邮箱$ git config --global user.name &quot;git&quot; $ git config --global user.email &quot;git@gmail.com&quot; ## 查看当前配置$ git config --list # 查看 0x02 创建 Git 仓库1 从远程仓库克隆到本地123$ git clone git://github.com/schacon/grit.git$ git clone git://github.com/schacon/grit.git mygrit # local path$ git clone git://github.com/schacon/grit.git mygrit --recursive # 递归拉取子module 2 Create a new repository123456$ echo &quot;Git Hand Book&quot; &gt;&gt; README.md$ git init$ git add README.md$ git commit -m &quot;add README&quot;$ git remote add origin git://github.com/schacon/grit.git$ git push -u origin master 3 Existing folder123456$ cd existing_folder$ git init$ git remote add origin git://github.com/schacon/grit.git$ git add .$ git commit$ git push -u origin master 4 Existing Git repository1234$ cd existing_repo$ git remote add origin git://github.com/schacon/grit.git$ git push -u origin --all$ git push -u origin --tags 0x03 Git 分支1 查看分支12$ git branch -a # 查看所有分支$ git branch -v # 查看各个分支对应的版本 2 切换分支123$ git branch iss53 # 新建$ git checkout iss53 # 切换$ git checkout -b hotfix # 新建并切换 3 创建分支3.1 创建本地分支，远程分支，并关联 1234$ git checkout -b serverfix origin/serverfix # 新建本地开发分支$ git push origin serverfix # 推送本地分支到远程$ git branch --set-upstream-to=origin/serverfix # 设置关联远程分支$ git branch -a # 查看分支 3.2 创建独立分支 12$ git checkout --orphan &lt;branch-name&gt; # 创建独立分支（但是暂存了所有原分支的文件）$ git rm -rf . # 删除原项目分支的所有历史和文件 4 删除分支4.1 删除本地分支 1$ git branch -D develop # 删除本地develop分支 4.2 删除远程分支 1$ git push origin :develop # 删除远程develop分支 4.3 远程分支已经删除，本地通过 git branch -a 还能看到 12$ git remote show origin # 可以查看remote地址，远程分支，还有本地分支与之相对应关系等信息。$ git remote prune origin # 删除本地那些远程仓库不存在的分支 5 合并分支5.1 方式一 merge12$ git checkout master # 切换到 master$ git merge develop # 合并devlop分支 merge 遇到冲突，先解决冲突，然后 12$ git add &lt;filename&gt; # 添加已经解决冲突的文件$ git commit # 此处不需要 -m 标签 5.2 方式二 rebase12345$ git checkout develop # 切换到 develop$ git rebase master # 变基到 master## 以上两条命令等价于下面这条 $ git rebase master develop # git rebase [base-branch] [topic-branch] 然后回到 master 分支进行快速合并 12$ git checkout master$ git merge develop # 合并devlop分支 rebase 遇到冲突，先解决冲突，然后 12$ git add &lt;filename&gt; # 添加已解决冲突的文件$ git rebase --continue 5.3 Git rebase高级用法​ 5.3.1 解除特殊情境下两个分支的依赖关系 12345 H---I---J topicB / E---F---G topicA /A---B---C---D master 1$ git rebase --onto master topicA topicB 12345 H'--I'--J' topicB / | E---F---G topicA |/A---B---C---D master 5.3.2 删除部分提交 1E---F---G---H---I---J topicA 1git rebase --onto topicA~5 topicA~3 topicA 1E---H'---I'---J' topicA 5.3.3 可交互式变基 交互式变基意味着您有机会编辑被重基的提交。 您可以重新排序提交，并可以删除它们(清除坏的或不需要的补丁) 12345$ git rebase -i master # edit the current branch commit before merge into master$ git rebase -i &lt;after-this-commit&gt; # Start it with the last commit you want to retain$ git rebase -i HEAD~5 # edit the last 5 commits 然后根据vim提示操作，最后:wq保存退出就可以执行当前操作 0x04 Git remote 使用123456789101112$ git remote add origin git://github.com/paulboone/ticgit.git # 添加远程库$ git remote set-url origin &lt;newurl&gt; # 替换远程库地址$ git remote # 查看远程库简称$ git remote -v # 查看所有远程库$ git remote show origin # 查看origin仓库信息$ git fetch [remote-name]$ git pull # git fetch &amp;&amp; git merge$ git push origin master$ git remote rename origin paul # 重命名$ git remote rm origin # 删除 0x05 Tags 标签1 常用标签管理命令12345$ git tag$ git tag v1.4-lw # 轻量级标签$ git tag -a v1.0 21f1f43 -m &quot;my version 1.0&quot; # 含附注标签（推荐）$ git show v1.0$ git push origin --tags # push 所有本地标签 2 仅使用远程仓库tags1$ git tag -l | xargs git tag -d &amp;&amp; git fetch -t # 使用远程仓库 tags 并且删除本地 tags 0x06 子模块123$ git submodule add http://framework.git framework$ git clone project.git project3 --recursive$ git submodule update --init --recursive 0x07 Git Stashing12345$ git stash$ git stash list$ git stash apply 0$ git stash pop$ git stash clear 0x08 Git 经常遇到的问题1 git pull 时遇到 error: cannot lock ref ‘xxx’git pull 时经常遇到 error: cannot lock ref 'refs/remotes/origin/dev': is at xxx but expected xxx 问题原因： 在git push的时候使用了git push –force，导致远端分支被覆盖，导致你本地的refs与远端不一致。 删除掉这个远端分支又重新新建了这个分支也会出现同样的问题。 12$ git update-ref -d refs/remotes/origin/dev$ git pull -p 2 回退到指定版本12$ git reset --hard e418f25$ git push origin HEAD --force 3 撤销操作12$ git reset HEAD benchmarks.rb # 取消已经暂存的文件（本地修改还在）$ git checkout -- benchmarks.rb # 还原文件的修改（删除修改） 4 修补上一次提交遗漏（push 前使用）123$ git commit -m 'initial commit' $ git add forgotten_file$ git commit --amend 5 图形化日志1$ git log --oneline --decorate --graph 0x09 Git Flow 0x99 .gitignore 文件123456# 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt","link":"/blog/2020/02/08/Git%E6%89%8B%E5%86%8C/"},{"title":"Gradle常用命令","text":"Gradle常用命令0x01 快速构建命令1234567891011121314151617181920212223242526272829303132# 查看构建版本./gradlew -v# 清除build文件夹./gradlew clean# 检查依赖并编译打包./gradlew build# 编译并安装debug包./gradlew installDebug# 编译并打印日志./gradlew build --info# 译并输出性能报告，性能报告一般在 构建工程根目录 build/reports/profile./gradlew build --profile# 调试模式构建并打印堆栈日志./gradlew build --info --debug --stacktrace# 强制更新最新依赖，清除构建并构建./gradlew clean build --refresh-dependencies# 离线模式./gradlew aDR --offline# 守护进程./gradlew build --daemon# 并行编译模式./gradlew build --parallel --parallel-threads=N 0x02 构建并安装命令123456789101112131415161718192021222324# 编译并打Debug包./gradlew assembleDebug# 这个是简写 assembleDebug./gradlew aD# 编译并打Release的包./gradlew assembleRelease# 这个是简写 assembleRelease./gradlew aR# Debug模式打包并安装./gradlew install app:assembleDebug# Release模式打包并安装./gradlew installRelease# 卸载Release模式包./gradlew uninstallRelease# Flavor渠道包./gradlew install app:assemble&lt;Flavor&gt;Debug 0x03 查看包依赖12345678910111213141516./gradlew dependencies# 查看app模块依赖./gradlew app:dependencies# 检索依赖库./gradlew app:dependencies | grep CompileClasspath# windows 没有 grep 命令./gradlew app:dependencies | findstr &quot;CompileClasspath&quot;# 将检索到的依赖分组找到 比如flavorDebugCompileClasspath就是flavor渠道分发的开发编译依赖./gradlew app:dependencies --configuration &lt;flavor&gt;DebugCompileClasspath# 依赖树过长可以保存到本地文件方便查看./gradlew app:dependencies --configuration &lt;flavor&gt;DebugCompileClasspath &gt;1.log","link":"/blog/2020/02/28/Gradle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Gradle的配置","text":"Gradle的配置原文地址：https://www.cnblogs.com/baiqiantao/p/6890674.html Installing Gradle: https://docs.gradle.org/current/userguide/installation.html gradlew 和 gradlew.bat：封装 gradle 的脚本，目的是为了更方便的使用 gradle 环境变量 GRADLE_HOME：仅仅是为了可以在任意目录中执行 gradle 命令，没有特殊的意义 环境变量 GRADLE_USER_HOME：控制在命令行中执行 gradlew 命令时，gradle 下载的目录 IDEA 的 Gradle user home：控制在 IDEA 点击按钮执行各项 Task 等功能时，gradle 下载的目录 IDEA 的 User from gradle：控制在 IDEA 点击按钮执行各项 Task 等功能时，使用的 gradle 的版本 环境变量 GRADLE_HOME设置环境变量 GRADLE_HOME 的目的，仅仅是为了方便在 Path 中指定 gradle 的位置。GRADLE_HOME：D:_dev\\gradle_GRADLE_HOME\\gradle-6.7Path：%GRADLE_HOME%\\bin将 gradle 添加到 Path 的目的是为了，可以在任意目录中执行 gradle 命令。实际上，完全没必要设置环境变量 GRADLE_HOME，Do we really need GRADLE_HOME? 123456gradle -v # 查看版本gradle --help # 查看命令使用帮助λ where gradle # 查看 gradle 命令位置D:\\_dev\\gradle\\GRADLE_HOME\\gradle-6.7\\bin\\gradleD:\\_dev\\gradle\\GRADLE_HOME\\gradle-6.7\\bin\\gradle.bat gradlew 是干嘛的其实 gradlew 只是一个 gradle 的封装(wrapper)，gradlew = gradle wrapper，因为在项目根目录有 gradlew 和 gradlew.bat 这两个可执行文件，所以 能且仅能 在项目根目录中执行 gradlew 命令。 123456D:\\_dev\\_code\\as\\Test&gt; gradlew -v # 查看版本D:\\_dev\\_code\\as\\Test&gt; gradlew --help # 查看命令使用帮助D:\\_dev\\_code\\as\\Test&gt; where gradlew # 查看 gradlew 命令位置D:\\_dev\\_code\\as\\Test\\gradlewD:\\_dev\\_code\\as\\Test\\gradlew.bat 这两个文件头部的注释也说明了他们的作用： gradlew：Gradle start up script for UN*X gradlew.bat：Gradle startup script for Windows 之所以添加这个 gradlew 脚本，是为了： 统一项目所使用的 gradle 版本，避免不同开发人员使用不同的 gradle 版本导致的兼容性问题可以把 gradle-wrapper.properties 里面的下载 gradle 的地址切换到公司的公共空间上，以加快下载速度 1distributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-all.zip 环境变量 GRADLE_USER_HOME设置环境变量 GRADLE_USER_HOME 的目的，是为了自定义下载 gradle 时的本地存储路径。在命令行中执行 gradlew 命令(注意不是 gradle 命令)时，会将对应版本的 gradle 下载到此目录中。下载 gradle 时，下载地址及版本由项目中的 /gradle/wrapper/gradle-wrapper.properties 决定。 123456#Mon Nov 16 00:55:48 CST 2020distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-all.zip IDEA 的 Gradle user home在 IDEA 的 File | Settings | Build, Execution, Deployment | Build Tools | Gradle 中，有一个 Gradle user home 的配置，其作用和环境变量 GRADLE_USER_HOME 类似，只不过该配置只是给 IDEA 使用的。譬如点击 gradle 窗口的各种 Task 按钮执行各项 Task 功能时。 注意：仅 IDEA 中的各种图形化操作会使用此配置，在 IDEA 的 Terminal 中执行 gradlew 命令时，使用的依旧是环境变量 GRADLE_USER_HOME。 IDEA 的 User from gradle在 IDEA 的 File | Settings | Build, Execution, Deployment | Build Tools | Gradle 中，有一个 User from gradle 的配置，它也是仅提供给 IDEA 使用的(对 gradlew 无效)。 其作用是，指定当前工程中 IDEA 所使用的 gradle 版本： 当勾选 gradle-wrapper.properties 时，使用 gradle-wrapper.properties 中指定的 gradle 版本。为了防止和在 Terminal 中执行 gradlew 命令时使用的 gradle 版本不同，建议勾选此配置(也是默认配置)。当勾选 Specified location 时，使用指定目录下的 gradle 版本。如果 gradle 下载很慢，就可以勾选此配置，以便使用指定本地下载好的 gradle 版本。 不管在 IDEA 中怎么配置，在 Terminal 中执行 gradlew 命令时，所使用的 gradle 版本都是由 gradle-wrapper.properties 决定的，并且下载路径也都是由环境变量 GRADLE_USER_HOME 决定的。 Gradle 依赖的 JDK 配置这里的 JDK 指的是执行 Gradle 命令依赖的 JDK，并非 AndroidStudio 工程依赖的 JDK。 通过 File | Settings | Build, Execution, Deployment | Build Tools | Gradle 设置的 JDK，是在运行 IDEA 图形化按钮时使用的。通过 gradle.properties 设置的 JDK，是在 Terminal 中执行 gradlew 命令时使用的。 1org.gradle.java.home=C\\:/_dev/Android/Android Studio/jre 注意：AGP 从 7.0.0-alpha02 版本起，需要使用 Java 11","link":"/blog/2022/08/15/Gradle%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"title":"Gradle配置构建多Module项目","text":"Gradle配置构建多Module项目0x01 配置远程代码库可以按如下方式声明特定的 Maven 或 Ivy 代码库： 12345678allprojects { repositories { maven { url 'https://maven.aliyun.com/repository/public' } // public仓是包含central仓和jcenter仓的聚合仓 maven { url 'https://maven.aliyun.com/repository/google' } // 阿里镜像库 maven { url &quot;file://local/repo/&quot; } // 本地文件代码库 ivy { url &quot;https://repo.example.com/ivy&quot; } // Ivy代码库 }} 0x02 统一配置Gradle依赖库版本随着项目采用模块化，组件化开发，moudle 的个数也会随着增加，统一管理配置gradle就显得比较重要了。 1、在 project 根目录创建一个 config.gradle 文件 123456789101112131415161718192021ext { // app 相关版本控制 versions = [ compileVersion : 26, buildVersion : &quot;26.0.2&quot;, sdkMinVersion : 15, sdkTargetVersion : 26, appVersionCode : 520, appVersionName : &quot;1.0.0&quot; ] // support依赖 support = [ appcompat : &quot;com.android.support:appcompat-v7:26.+&quot;, recyclerview: &quot;com.android.support:recyclerview-v7:26.+&quot; ] // 依赖 deps = [ glide : &quot;com.github.bumptech.glide:glide:4.11.0&quot; ] } 2、在 Project 根目录下的 build.gradle 添加apply 1apply from: 'config.gradle' 3、在相应Moudle中调用 123456789101112131415161718192021222324252627android { def versions = rootProject.ext.versions compileSdkVersion versions.compileVersion buildToolsVersion versions.buildVersion defaultConfig { applicationId &quot;com.dench.wanandroid&quot; minSdkVersion versions.sdkMinVersion targetSdkVersion versions.sdkTargetVersion versionCode versions.appVersionCode versionName versions.appVersionName } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } } dependencies { def dependencies = rootProject.ext.deps def support = rootProject.ext.support implementation support.appcompat implementation support.recyclerview implementation dependencies.glide } 0x03 配置Flavor创建产品变种与创建构建类型类似：将其添加到构建配置中的 productFlavors 代码块并添加所需的设置。产品变种支持与 defaultConfig 相同的属性，这是因为，defaultConfig 实际上属于 ProductFlavor 类。这意味着，您可以在 defaultConfig 代码块中提供所有变种的基本配置，每个变种均可更改其中任何默认值，如 applicationId。 1234567891011121314151617181920212223android { defaultConfig {...} buildTypes { debug{...} release{...} } // Specifies one flavor dimension. flavorDimensions &quot;version&quot; productFlavors { demo { dimension &quot;version&quot; applicationIdSuffix &quot;.demo&quot; versionNameSuffix &quot;-demo&quot; versionCode 30000 + android.defaultConfig.versionCode } full { dimension &quot;version&quot; applicationIdSuffix &quot;.full&quot; versionNameSuffix &quot;-full&quot; versionCode 20000 + android.defaultConfig.versionCode } }} 0x04 创建源代码集1、Gradle 要求： 在所有构建变体之间共享的所有内容创建 main/ 源代码集和目录。 将“debug”构建类型特有的 Java 类文件放在 src/debug/java/ 目录中。 12345678910111213debug----Compile configuration: compilebuild.gradle name: android.sourceSets.debugJava sources: [app/src/debug/java]Manifest file: app/src/debug/AndroidManifest.xmlAndroid resources: [app/src/debug/res]Assets: [app/src/debug/assets]AIDL sources: [app/src/debug/aidl]RenderScript sources: [app/src/debug/rs]JNI sources: [app/src/debug/jni]JNI libraries: [app/src/debug/jniLibs]Java-style resources: [app/src/debug/resources] 依次转到 MyApplication &gt; Tasks &gt; android，然后双击 sourceSets。Gradle 执行该任务后，系统应该会打开 Run 窗口以显示输出。 2、更改默认源代码集配置 123456789android { sourceSets { main { java.srcDirs = ['other/java'] res.srcDirs = ['other/res1', 'other/res2'] manifest.srcFile 'other/AndroidManifest.xml' } }} 0x05 声明依赖项123456dependencies { // Adds the local &quot;mylibrary&quot; module as a dependency to the &quot;free&quot; flavor. freeImplementation project(&quot;:mylibrary&quot;) testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'} 0x06 配置签名1、在项目的根目录下创建一个名为 keystore.properties 的文件，并使其包含以下信息： 1234storePassword=myStorePasswordkeyPassword=myKeyPasswordkeyAlias=myKeyAliasstoreFile=myStoreFileLocation 2、在 build.gradle 文件中，按如下方式加载 keystore.properties 文件（必须在 android 代码块前面）： 12345678def keystorePropertiesFile = rootProject.file(&quot;keystore.properties&quot;)def keystoreProperties = new Properties()keystoreProperties.load(new FileInputStream(keystorePropertiesFile))// before androidandroid { } 3、输入存储在 keystoreProperties 对象中的签名信息： 123456789101112131415android { signingConfigs { release { keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] } } buildTypes { release { signingConfig signingConfigs.release } }} 如需从环境变量获取这些密码，请添加以下代码： 12storePassword System.getenv(&quot;KSTOREPWD&quot;)keyPassword System.getenv(&quot;KEYPWD&quot;) 0x07 apk重命名123456789android { applicationVariants.all { variant -&gt; if (variant.buildType.name == 'release') { variant.outputs.all { outputFileName = &quot;app_v${variant.versionName}.${buildTime}_${variant.productFlavors[0].name}_${variant.buildType.name}.apk&quot; } } }} or 123outputFileName = &quot;app_v${versionName}.${buildTime}_${flavorName}_${buildType.name}.apk&quot;outputFileName = &quot;../../${outputFileName}&quot;println outputFileName 0x08 将构建变量注入清单1、如果您需要将变量插入在 build.gradle 文件中定义的 AndroidManifest.xml 文件，可以使用 manifestPlaceholders 属性执行此操作。此属性采用键值对的映射，如下所示： 123456android { defaultConfig { manifestPlaceholders = [hostName:&quot;www.example.com&quot;] applicationId &quot;com.example.myapp&quot; }} 2、您可以将某个占位符作为属性值插入清单文件，如下所示： 1234&lt;intent-filter ... &gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;${hostName}&quot; ... /&gt; &lt;action android:name=&quot;${applicationId}.TRANSMOGRIFY&quot; /&gt;&lt;/intent-filter&gt; 0x09 gradle自定义Java变量和资源值在构建时，Gradle 将生成 BuildConfig 类，以便应用代码可以检查与当前构建有关的信息。您也可以从 Gradle 构建配置文件中使用 buildConfigField() 方法将自定义字段添加到 BuildConfig 类中，然后在应用的运行时代码中访问这些值。同样，您也可以使用 resValue() 添加应用资源值。 12345678910111213def buildTime = new Data().format(&quot;yyyyMMddHHmm&quot;, TimeZone.getTimeZone(&quot;GTM+08:00&quot;))android { buildTypes { release { buildConfigField(&quot;String&quot;, &quot;BUILD_TIME&quot;, &quot;\\&quot;${buildTime}\\&quot;&quot;) resValue(&quot;string&quot;, &quot;build_time&quot;, &quot;${buildTime}&quot;) } debug { buildConfigField(&quot;String&quot;, &quot;BUILD_TIME&quot;, &quot;\\&quot;0\\&quot;&quot;) resValue(&quot;string&quot;, &quot;build_time&quot;, &quot;0&quot;) } }} 在应用代码中，您可以按如下方式访问属性： 12Log.i(TAG, BuildConfig.BUILD_TIME);Log.i(TAG, getString(R.string.build_time)); 0x10 设定编码12345allprojects { tasks.withType(JavaCompile){ options.encoding = &quot;UTF-8&quot; }}","link":"/blog/2020/12/20/Gradle%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%A4%9AModule%E9%A1%B9%E7%9B%AE/"},{"title":"Gson 数据解析","text":"Gson 数据解析0x01 Kotlin Gson 解析 data class 两条黄金法则：1、 String 必须是可空类型 String?2、 需要使用默认值，则全部字段都必须给予默认值，以满足kotlin对象有空的构造函数0x02 手动解析Gson基础字段1、msg 可空String解析 jsonReader.peek() == JsonToken.NULL 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import com.google.gson.Gsonimport com.google.gson.JsonSyntaxExceptionimport com.google.gson.TypeAdapterimport com.google.gson.reflect.TypeTokenimport com.google.gson.stream.JsonReaderimport com.google.gson.stream.JsonTokenimport okhttp3.ResponseBodyimport retrofit2.Converterimport java.lang.reflect.ParameterizedTypeimport java.lang.reflect.Typeclass ResponseBodyConverter(val gson: Gson, val type: Type) : Converter&lt;ResponseBody, BaseResponse&lt;Any&gt;&gt; { override fun convert(value: ResponseBody): BaseResponse&lt;Any&gt; { val dataType = GenericsUtils.getParameterUpperBound( 0, type as ParameterizedType ) val baseResponse = BaseResponse&lt;Any&gt;() val jsonReader = JsonReader(value.charStream()) try { jsonReader.beginObject() while (jsonReader.hasNext()) { val name: String = jsonReader.nextName() when (name) { &quot;code&quot; -&gt; { baseResponse.code = jsonReader.nextString() } &quot;msg&quot; -&gt; { // this works, but do not do this. if (jsonReader.peek() == JsonToken.NULL) { jsonReader.nextNull() baseResponse.msg = null } else { baseResponse.msg = jsonReader.nextString() } } &quot;data&quot; -&gt; { val mapped: TypeAdapter&lt;*&gt;? = gson.getAdapter(TypeToken.get(dataType)) baseResponse.data = mapped?.read(jsonReader) } else -&gt; { jsonReader.skipValue() } } } } catch (e: IllegalStateException) { throw JsonSyntaxException(e) } catch (e: IllegalAccessException) { throw AssertionError(e) } jsonReader.endObject() return baseResponse }}","link":"/blog/2021/09/13/Gson%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"},{"title":"Hexo &amp; NexT 搭建个人网站","text":"1. 搭建环境（2020-2-6） Git(v2.21.1): https://www.git-scm.com/downloads/ Node.js(v12.14.1): https://nodejs.org/zh-cn/ Hexo(v4.2.0): https://hexo.io/ NexT(v7.7.1): https://theme-next.org/ 2. 安装 Hexo1$ npm install hexo-cli -g 3. 创建 hexo 工程新建工程1$ hexo init [folder] 新建post1$ hexo new [layout] &lt;title&gt; 编译工程1$ hexo generate 本地服务1$ hexo server 部署1$ hexo deploy 其他常用命令123$ hexo clean $ hexo g &amp;&amp; hexo s $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 4. 一键发布到 Github 和 Coding 4.1 安装 hexo-deployer-git. 4.2 配置 hexo/_config.yml, 添加代码: 1234567deploy: repo: # 下面两种写法都支持 github: https://github.com/user/project.git,branch coding: url: https://git.coding.com/user/project.git branch: branch_name 4.3 部署使用 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d. 5. 配置工程hexo/_config.yml12345678910title: subtitle: author: description: #描述 SEO language: zh-CNtimezone: #建议不填skip_render: - README.md - CNAME 6. 安装主题 NexT 6.1 NexT 主题下载 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 6.2 应用主题，配置hexo/_config.yml: 1theme: next 更多主题: https://github.com/hexojs/hexo/wiki/Themes 7. 配置主题 NexT以下配置都在 NexT 主题配置文件 next/_config.yml 。 7.1 选择 Scheme1234#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 7.2 选择语言1language: zh-CN 7.3 配置 menu123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 7.4 配置 Tags 和 Categories menu 中配置 tags 和 categories，需要自定义 page。自定义Tags 7.5 配置 Sidebar1234567891011# Sidebar Avataravatar: # Replace the default image and set the url here. url: /images/avatar.png # If true, the avatar will be dispalyed in circle. rounded: true # If true, the avatar will be rotated with the cursor. rotated: false# Posts / Categories / Tags in sidebar.site_state: true 7.6 配置 Favicon1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg android_manifest: /images/manifest.json ms_browserconfig: /images/browserconfig.xml 7.7 配置 Back2top123456back2top: enable: true # Back to top in sidebar. sidebar: false # Scroll percent label in b2t button. scrollpercent: true 7.8 配置字体123456font: enable: true global: external: true family: Menlo size: 1.125 7.9 GitHub Banner1234github_banner: enable: true permalink: https://github.com/yourname title: Follow me on GitHub 7.10 阅读全文（控制首页显示位置） 在 &lt;_post&gt;.md 中添加 &lt;!-- more --&gt; 标签 更多主题配置: https://theme-next.org/docs/theme-settings/","link":"/blog/2020/02/06/Hexo%E5%92%8CNexT%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"},{"title":"Homebrew 入门","text":"Homebrew 是 macOS 或 Linux 缺失的软件包的管理器. Homebrew 官网: https://brew.sh/ 1. 安装1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2. 使用国内镜像brew update 卡死，没反应？原因一般都是国内获取资源太慢，可以使用国内镜像解决。 control-C 直接终止当前前台update进程。 2.1 替换 Homebrew 源12cd &quot;$(brew --repo)&quot;git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 2.2 替换 Homebrew Core 源12cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 2.3 替换 Homebrew Cask 源12cd &quot;$(brew --repo)&quot;/Library/Taps/homebrew/homebrew-caskgit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git 2.4 修改 Homebrew Bottles 变量在运行 brew 前设置环境变量 HOMEBREW_BOTTLE_DOMAIN ，值为 https://mirrors.ustc.edu.cn/homebrew-bottles 。 对于 bash 用户： 12echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profilesource ~/.bash_profile 对于 zsh 用户： 12echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &gt;&gt; ~/.zshrcsource ~/.zshrc 3. Homebrew 常用命令1234567891011Example usage: brew info [FORMULA...] brew install FORMULA... brew update brew upgrade [FORMULA...] brew uninstall FORMULA... brew list [FORMULA...]Troubleshooting: brew config brew doctor 4. 关于 Homebrew gem 和 npm 介绍Homebrew介绍Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件。相当于Linux听的yum、apt-get等软件管理工具。 RubyGems介绍RubyGems简称gem，RubyGems是一个包管理框架，提供了ruby社区的gem的托管服务，用于ruby软件包的下载、安装、使用；ruby的软件包被称为gem，包含了ruby应用或库。和brew不同，brew用于操作系统层面上的软件包的安装，而gem只是管理ruby软件 123456789gem --versiongem install rakegem list --localgem build package.gemspecgem help install npm介绍npm，是node.js界的程序/模块管理工具，也就是说npm只管理那些服务于JavaScript社区的程序。而且跨平台，windows和osx，以及其他unix like操作系统都可以用。 123456789npm versionnpm helpnpm list -g // 查看 npm 安装包列表npm outdated -g // 待更新安装包npm install hexo-cli -g // 安装，或者更新","link":"/blog/2020/02/10/Homebrew%E5%85%A5%E9%97%A8/"},{"title":"implementation compileOnly和api","text":"implementation和apiimplementation和api是取代之前的compile的，其中api和compile是一样的效果，implementation有所不同，通过implementation依赖的库只能自己库本身访问，举个例子，A依赖B，B依赖C，如果B依赖C是使用的implementation依赖，那么在A中是访问不到C中的方法的，如果需要访问，请使用api依赖 compile onlycompile only和provided效果是一样的，只在编译的时候有效， 不参与打包 runtime onlyruntimeOnly 和 apk效果一样，只在打包的时候有效，编译不参与 跟编译环境相关 test implementation testImplementation和testCompile效果一样，在单元测试和打包测试apk的时候有效 debug implementation debugImplementation和debugCompile效果相同， 在debug模式下有效 release implementation releaseImplementation和releaseCompile效果相同，只在release模式和打包release包情况下有效","link":"/blog/2020/08/27/Implementation%E5%92%8Capi/"},{"title":"JDK签名工具jarsigner签名APK","text":"JDK签名工具jarsigner签名APK使用JDK签名工具jarsigner签名APK文件 jarsigner -verbose -keystore [签名文件路径] -signedjar [签名后的apk文件路径] [未签名的apk文件路径] [证书别名] 1jarsigner -verbose -keystore D:\\xxx\\xxx.jks -signedjar D:\\xxx\\xxx_signed.apk D:\\xxx\\***.apk keyAlias","link":"/blog/2023/01/10/JDK%E7%AD%BE%E5%90%8D%E5%B7%A5%E5%85%B7jarsigner%E7%AD%BE%E5%90%8DAPK/"},{"title":"Java内存模型JMM","text":"Java内存模型java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的。 0x01.主内存与工作内存java内存模型规定了所有的变量都存储在住内存。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的主内存中的变量的拷贝。线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量传递均需要通过主内存来完成。当多个线程操作的变量涉及到同一个主内存区域，将可能导致各自的工作线程数据不一致，这样就导致变量同步回主内存的时候可能冲突导致数据丢失。 这里需要说明一下： 1.主内存、工作内存与java内存区域中的java堆、虚拟机栈、方法区并不是一个层次的内存划分。 2.这里的变量跟我们写java程序中的变量不是完全等同的。这里的变量是指实例字段，静态字段，构成数组对象的元素，但是不包括局部变量和方法参数(因为这是线程私有的)。这里可以简单的认为主内存是java虚拟机内存区域中的堆，局部变量和方法参数是在虚拟机栈中定义的。但是在堆中的变量如果在多线程中都使用，就涉及到了堆和不同虚拟机栈中变量的值的一致性问题了。 0x02.主内存与工作线程交互的基本操作主内存与工作线程交互的基本操作有以下几种： lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态 unlock（解锁）：作用于主内存的变量，释放锁定状态的变量 read（读取）：作用于主内存的变量，把一个变量从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作 assign（赋值）：作用于工作内存的变量，把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作 store（存储）：作用于工作内存的变量，把工作内存的一个变量值传送到主内存，以便随后的write操作使用 write（写入）：作用于主内存的变量，把store操作从工作内存得到的变量的值放入主内存变量中 虚拟机实现必须保证上面的每一种操作都是原子的。 如果要把一个变量从主内存复制到工作内存，需要顺序执行read和load操作；如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。 0x03.交互规则还规定上述8中基本操作时必须满足如下规则： 1、read和load，store和write必须成对出现2、不允许一个线程丢弃它的最近的assign操作，变量在工作内存中改变后必须写回主内存3、不允许一个线程将没有assign过的数据从工作线程同步回主内存4、一个新的变量只能在主内存中诞生，不允许工作内存中直接使用一个未被初始化（load或assgin）的变量，对一个变量进行use，store之前必须load，assign5、一个变量同一时刻只允许一条线程对其进行lock，同一个线程对lock操作可重复执行多次，之后需要执行相同次数的unlock变量才会被解锁6、对变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。7、一个变量未被lock不允许unlock，并且不能unlock一个被其他线程锁定住的变量8、对一个变量执行unlock操作前，必须先把此变量同步回主内存中 0x04.volatile的特殊规则1）Java内存模型对volatile变量定义了特殊规则： 假定T表示一个线程，V和W分别表示两个volatile型变量，那么进行read，load，use，assign，store，write操作时需要满足如下规则1、线程T对变量V执行的load和use操作必须成对执行，即执行的前一个动作是load，后一个动作才能是use。后一个动作是use，前一个动作才能是load，线程T对变量V的use动作可以认为是和线程T对变量V的load，read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值） 2、与1相对的，线程T对变量V执行的assign和store操作必须成对执行，线程T对变量V的assign动作可以认为是和线程T对变量V的store，write动作相关联，必须连续一个出现（这条规则要求在工作线程中，每次修改V后都必须立刻同步会主内存中，用于保证其他线程可以看到自己对变量V所做的修改） 3、假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同） java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性。volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。 2）volatile对指令重排序的实现： volatile修饰的变量，赋值后多执行了一个“lock addl $0x0,(%esp)”操作，这个操作相当于一个屏障。lock的作用是使得本CPU的Cache写入了内存，该写入动作也会引起别的CPU或者别的内核无效化其Cache，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作。所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。lock addl $0x0,(%esp。) 命令把修改同步回内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。","link":"/blog/2020/08/13/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/"},{"title":"Kotlin单例","text":"Kotlin单例下面介绍一下kotlin 线程安全的几种单例写法。 0x01 饿汉模式123// Kotlin实现object Singleton {} 123456789101112// 反编译Kotlin实现的Java代码public final class Singleton { public static final Singleton INSTANCE; private Singleton() { } static { Singleton var0 = new Singleton(); INSTANCE = var0; }} 0x02 双重校验锁式双重校验锁式（Double Check) 12345678910111213141516171819// Kotlin实现class Singleton private constructor() { companion object { @Volatile private var instance: Singleton? = null @JvmStatic fun getInstance(): Singleton { if (instance == null) { synchronized(Singleton::class.java) { if (instance == null) { instance = Singleton() } } } return instance!! } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 反编译Kotlin实现的Java代码public final class Singleton { private static volatile Singleton instance; public static final Singleton.Companion Companion = new Singleton.Companion((DefaultConstructorMarker)null); private Singleton() { } // $FF: synthetic method public Singleton(DefaultConstructorMarker $constructor_marker) { this(); } @JvmStatic @NotNull public static final Singleton getInstance() { return Companion.getInstance(); } public static final class Companion { @JvmStatic @NotNull public final Singleton getInstance() { if (Singleton.instance == null) { Class var1 = Singleton.class; boolean var2 = false; boolean var3 = false; synchronized(var1) { int var4 = false; if (Singleton.instance == null) { Singleton.instance = new Singleton((DefaultConstructorMarker)null); } Unit var6 = Unit.INSTANCE; } } Singleton var10000 = Singleton.instance; if (var10000 == null) { Intrinsics.throwNpe(); } return var10000; } private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }} 0x03 静态内部类123456789101112//Java实现public class SingletonDemo { private static class SingletonHolder{ private static SingletonDemo instance=new SingletonDemo(); } private SingletonDemo(){ System.out.println(&quot;Singleton has loaded&quot;); } public static SingletonDemo getInstance(){ return SingletonHolder.instance; }} 1234567891011// Kotlin实现class Singleton private constructor() { companion object { @JvmStatic fun getInstance() = SingletonHolder.instance } private object SingletonHolder { @JvmStatic val instance: Singleton = Singleton() }} 12345678910111213141516171819202122232425262728293031323334// 反编译Kotlin实现的Java代码public final class Singleton { public static final Singleton.Companion Companion = new Singleton.Companion((DefaultConstructorMarker)null); private Singleton() { } @JvmStatic @NotNull public static final Singleton getInstance() { return Companion.getInstance(); } private static final class SingletonHolder { @NotNull private static final Singleton instance; public static final Singleton.SingletonHolder INSTANCE; @NotNull public static final Singleton getInstance() { return instance; } static { Singleton.SingletonHolder var0 = new Singleton.SingletonHolder(); INSTANCE = var0; instance = new Singleton((DefaultConstructorMarker)null); } } public static final class Companion { @JvmStatic @NotNull public final Singleton getInstance() { return Singleton.SingletonHolder.getInstance(); } private Companion() { } }}","link":"/blog/2021/11/30/Kotlin%E5%8D%95%E4%BE%8B/"},{"title":"观察者模式Kotlin泛型实现消息中心","text":"观察者模式 + Kotlin 泛型实现的简易版消息中心 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class MessageCenter&lt;T&gt; { companion object { private val centers = mutableMapOf&lt;String, Any&gt;() fun &lt;T&gt; getInstance(clazz: Class&lt;T&gt;): MessageCenter&lt;T&gt; { return if (centers[clazz.simpleName] != null) { centers[clazz.simpleName] as MessageCenter&lt;T&gt; } else { val messageCenter = MessageCenter&lt;T&gt;() centers[clazz.simpleName] = messageCenter messageCenter } } } fun register(observer: Observer&lt;T&gt;) { observers.add(observer) } fun unregister(observer: Observer&lt;T&gt;) { if (observers.contains(observer)) { observers.remove(observer) } } fun post(t: T) { observers.forEach { it.receive(t) } } private var observers = mutableListOf&lt;Observer&lt;T&gt;&gt;()}interface Observer&lt;T&gt; { fun receive(t: T)}fun main() { val ob = object : Observer&lt;String&gt; { override fun receive(t: String) { println(&quot;result is: $t&quot;) } } MessageCenter.getInstance(String::class.java).register(ob) MessageCenter.getInstance(String::class.java).post(&quot;txt post.&quot;) MessageCenter.getInstance(String::class.java).unregister(ob) MessageCenter.getInstance(Int::class.java).post(123)}","link":"/blog/2021/05/21/MessageCenter/"},{"title":"PowerShell最佳实践","text":"PowerShell最佳实践Windows 10 系统自带 PowerShell，美化教程 0x01 安装Fluent Terminal在Windows 应用商店安装，或者Github 0x02 安装powershell模块1、安装posh-git、oh-my-posh和Get-ChildItemColor(美化ls命令)： 在powershell管理员模式下： 123$ Install-Module posh-git -Scope CurrentUser$ Install-Module oh-my-posh -Scope CurrentUser$ Install-Module DirColors 2、设置修改powershell的配置文件： 12$ if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }$ notepad $PROFILE 输入内容： 1234Import-Module DirColorsImport-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme PowerLine 其中主题名可以在下面的路径里找到,可以自行切换主题。 1C:\\Program Files\\WindowsPowerShell\\Modules\\oh-my-posh\\3.163.0\\themes 0x03 安装Powerline字体在Fluent Terminal设置 powerline 字体和字体大小。 0x04 文件管理器命令在文件夹中打开： 12345678# I 在文件夹中打开$ explorer (gl)# II 在文件夹中打开$ start .# III 在文件夹中打开$ ii .# 打开当前根目录$ ii / 在当前文件夹打开PowerShell： 空白处 Shift + 鼠标右键，在弹出的菜单中选择PowerShell. 0x05 VS Code 命令1$ code .","link":"/blog/2021/06/17/PowerShell%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"Problems专题：Dialog","text":"Problems专题：Dialog0x01 OnKeyDown部分机型无法监听问题分析 监听返回键和音量键，重载OnKeyDown()方法，部分机型会失效。 解决方案 给相应的Dialog监听setOnKeyListener()。 12345678910// 解决不同机型版本兼容问题，onKeyDown 可能被拦截setOnKeyListener { dialog, keyCode, event -&gt; Log.d(TAG, &quot;setOnKeyListener: keyCode = $keyCode, event = $event&quot;) if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) { handleKeyEvent(keyCode) true } else { false }} 注意区分keycode，防止业务层重复处理 0x02 DialogFragment不能自动弹出软键盘方案一：延迟弹出软键盘在dialog显示之后，延迟200ms再显示软键盘 1234567891011121314151617181920//强制显示或者关闭系统键盘public static void toggleKeyboard(final EditText editText, final boolean status) { if (editText == null) return; Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { InputMethodManager m = (InputMethodManager) ApplicationExtKt.getAppContext().getSystemService(Context.INPUT_METHOD_SERVICE); if (status) { m.showSoftInput(editText, InputMethodManager.SHOW_FORCED); } else { IBinder windowToken = editText.getWindowToken(); if (windowToken != null) { m.hideSoftInputFromWindow(windowToken, 0); } } } }, status ? 200 : 100);} 方案二：设置 SoftInputMode 为 SOFT_INPUT_STATE_ALWAYS_VISIBLE 12getDialog().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);inputEditText.requestFocus(); 0x03 关闭DialogFragment无法关闭软键盘问题分析 一般情况下，在onPause或者dismiss方法直接调用hideKeyboard就可以 1234override fun onPause() { KeyBoardUtils.hideKeyboard(binding.etSearch) super.onPause()} 但是，在某些时候还是会存在关闭不成功的情况。这是由于Dialog下面的Activity或Fragment存在EditText等抢占焦点，导致在DialogFragment在调用dismiss方法时，键盘已经被抢占焦点，所以无法关闭。 解决方案 在DialogFragment的dismiss方法回调 1234override fun onDismiss(dialog: DialogInterface) { listener?.onDialogDismiss() super.onDismiss(dialog)} 在前一个Activity或者Fragment中重新关闭键盘。 1234567// 消除弹框遗留下来的keyboardprivate fun onDialogDismiss() { // 消除弹框 Handler().postDelayed({ KeyBoardUtils.hideKeyboard(binding.root) }, 200)}","link":"/blog/2021/06/17/Problems%E4%B8%93%E9%A2%98%E4%B9%8BDialog/"},{"title":"Problems专题之Gradle","text":"Problems专题之Gradle0x01 More than one file was found with OS independent path ‘META-INF/webview_release.kotlin_module’这是因为第三方库中存在很多重名的META-INF文件，在打包的时候去除即可 123456789101112131415161718android { // ... packagingOptions { exclude 'META-INF/webview_release.kotlin_module' exclude 'META-INF/proguard/androidx-annotations.pro' exclude 'META-INF/gradle/incremental.annotation.processors' exclude 'META-INF/DEPENDENCIES' exclude 'META-INF/LICENSE' exclude 'META-INF/LICENSE.txt' exclude 'META-INF/license.txt' exclude 'META-INF/NOTICE' exclude 'META-INF/NOTICE.txt' exclude 'META-INF/notice.txt' exclude 'META-INF/ASL2.0' // ... }} 0x02 Certificate for &lt;x.x.x&gt; doesn’t match any of the subject alternative names在执行gradlew命令打包时遇到这个错误，肯定是https证书有问题。 解决方案：如果支持http的话就使用http 123456789&gt; Could not resolve com.bytedanceapi:ttsdk-ttmp:1.36.2.25.pcdn. Required by: project :player &gt; com.bytedanceapi:ttsdk-player_premium:1.36.2.25.pcdn &gt; com.bytedanceapi:ttsdk-ttplayer:1.36.2.25.pcdn &gt; Could not resolve com.bytedanceapi:ttsdk-ttmp:1.36.2.25.pcdn. &gt; Could not get resource 'https://artifact.bytedance.com/repository/Volcengine/com/bytedanceapi/ttsdk-ttmp/1.36.2.25.pcdn/ttsdk-ttmp-1.36.2.25.pcdn.pom'. &gt; Could not GET 'https://artifact.bytedance.com/repository/Volcengine/com/bytedanceapi/ttsdk-ttmp/1.36.2.25.pcdn/ttsdk-ttmp-1.36.2.25.pcdn.pom'. &gt; Certificate for &lt;artifact.bytedance.com&gt; doesn't match any of the subject alternative names: [*.alicdn.com, *.cmos.greencompute.org, cmos.greencompute.org, m.intl.taobao.com, *.mobgslb.tbcache.com, alikunlun.com, *.alikunlun.com, s.tbcdn.cn, *.django.t.taobao.com, alicdn.com] 把项目根目录的build.gradle文件中所有的https://artifact.bytedance.com/替换为http://artifact.bytedance.com/即可 Ox03 module java.base does not “opens java.io” to unnamed module升级到 Java 16 以上，AndroidStudio编译遇到错误。 Unable to make field private final java.lang.String java.io.File.path accessible: module java.base does not “opens java.io” to unnamed module @fb04536 解决方案一： 将 gradle-wrapper 属性中的 gradle 版本更改为 7.1.1（6.x 不支持 java 16） 在 gradle.properties 中添加以下行 123456org.gradle.jvmargs=-Xmx1536m \\--add-exports=java.base/sun.nio.ch=ALL-UNNAMED \\--add-opens=java.base/java.lang=ALL-UNNAMED \\--add-opens=java.base/java.lang.reflect=ALL-UNNAMED \\--add-opens=java.base/java.io=ALL-UNNAMED \\--add-exports=jdk.unsupported/sun.misc=ALL-UNNAMED 解决方案二： 升级build-gradlew版本。 将项目根目录的 build.gradle文件中classpath 'com.android.tools.build:gradle:4.2.2'升级为classpath 'com.android.tools.build:gradle:7.2.1'","link":"/blog/2023/07/05/Problems%E4%B8%93%E9%A2%98%E4%B9%8BGradle/"},{"title":"Problems专题：Parcel","text":"Problems专题：Parcel0x01 Unmarshalling unknown type1234567891011121314151617181920212223242526Thread Name: 'main' java.lang.RuntimeException: Parcel android.os.Parcel@bbfcc04: Unmarshalling unknown type code 2131296928 at offset 1088 at android.os.Parcel.readValue(Parcel.java:2750) at android.os.Parcel.readSparseArrayInternal(Parcel.java:3126) at android.os.Parcel.readSparseArray(Parcel.java:2354) at android.os.Parcel.readValue(Parcel.java:2728) at android.os.Parcel.readArrayMapInternal(Parcel.java:3045) at android.os.BaseBundle.initializeFromParcelLocked(BaseBundle.java:288) at android.os.BaseBundle.unparcel(BaseBundle.java:232) at android.os.Bundle.getSparseParcelableArray(Bundle.java:1010) at com.android.internal.policy.PhoneWindow.restoreHierarchyState(PhoneWindow.java:2133) at android.app.Activity.onRestoreInstanceState(Activity.java:1173) at android.app.Activity.performRestoreInstanceState(Activity.java:1128) at android.app.Instrumentation.callActivityOnRestoreInstanceState(Instrumentation.java:1318) at android.app.ActivityThread.handleStartActivity(ActivityThread.java:3025) at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:180) at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:165) at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:142) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:70) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1840) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:207) at android.app.ActivityThread.main(ActivityThread.java:6878) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876) 问题分析 情况1 Parcelable 对象为空，反序列化异常 情况2 Parcelable 序列化和反序列化的字段和顺序没有完全对应 情况3 自定义View的数据保存与恢复 解决方案 情况1 Parcelable 对象在序列化和反序列化增加 null 值判断 情况2 Parcelable 对象 read 和 write 字段的类型和顺序保持一直 1234567891011121314151617181920212223public class Account implements Parcelable { public Account(Parcel in) { this.name = in.readString(); this.type = in.readInt(); if (TextUtils.isEmpty(name)) { throw new android.os.BadParcelableException(&quot;the name must not be empty: &quot; + name); } // ... this.accessId = in.readString(); // ... } public int describeContents() { return 0; } public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); dest.writeInt(type); dest.writeString(accessId); } // ...} 情况3 自定义View的数据保存与恢复 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849override fun onSaveInstanceState(): Parcelable? { Log.d(&quot;NavigationBar&quot;, &quot;onSaveInstanceState: selectedId=${mSelectedId}&quot;) return SavedState(super.onSaveInstanceState(), mSelectedId)}override fun onRestoreInstanceState(state: Parcelable?) { if (state is SavedState) { val id = state.selectedId Log.d(&quot;NavigationBar&quot;, &quot;onRestoreInstanceState: selectedId=${state.selectedId}&quot;) super.onRestoreInstanceState(state.superState) select(id) return } return super.onRestoreInstanceState(state)}internal class SavedState : BaseSavedState { var selectedId: Int = View.NO_ID constructor(source: Parcel) : super(source) { selectedId = source.readInt() Log.d(&quot;NavigationBar&quot;, &quot;readFromParcel: selectedId=$selectedId&quot;) } constructor(superState: Parcelable?, selectedId: Int) : super(superState) { this.selectedId = selectedId } override fun writeToParcel(parcel: Parcel, flags: Int) { super.writeToParcel(parcel, flags) parcel.writeInt(selectedId) Log.d(&quot;NavigationBar&quot;, &quot;writeToParcel: selectedId=$selectedId&quot;) } override fun describeContents(): Int { return 0 } companion object CREATOR : Parcelable.Creator&lt;SavedState&gt; { override fun createFromParcel(parcel: Parcel): SavedState { return SavedState(parcel) } override fun newArray(size: Int): Array&lt;SavedState?&gt; { return arrayOfNulls(size) } }} 0x02 android.os.TransactionTooLargeException1234567891011121314151617181920212223242526272829303132333435java.lang.RuntimeException: android.os.TransactionTooLargeException: data parcel size 542688 bytes at android.app.servertransaction.PendingTransactionActions$StopInfo.run(PendingTransactionActions.java:160) at android.os.Handler.handleCallback(Handler.java:873) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:207) at android.app.ActivityThread.main(ActivityThread.java:6878) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876)Caused by: android.os.TransactionTooLargeException: data parcel size 542688 bytes at android.os.BinderProxy.transactNative(Native Method) at android.os.BinderProxy.transact(BinderProxy.java:479) at android.app.IActivityManager$Stub$Proxy.activityStopped(IActivityManager.java:3941) at java.lang.reflect.Method.invoke(Native Method) at com.taobao.monitor.impl.common.c.invoke(ActivityManagerHook.java:89) at java.lang.reflect.Proxy.invoke(Proxy.java:1006) at $Proxy2.activityStopped(Unknown Source) at android.app.servertransaction.PendingTransactionActions$StopInfo.run(PendingTransactionActions.java:144) ... 7 moreandroid.os.TransactionTooLargeException: data parcel size 542688 bytes at android.os.BinderProxy.transactNative(Native Method) at android.os.BinderProxy.transact(BinderProxy.java:479) at android.app.IActivityManager$Stub$Proxy.activityStopped(IActivityManager.java:3941) at java.lang.reflect.Method.invoke(Native Method) at com.taobao.monitor.impl.common.c.invoke(ActivityManagerHook.java:89) at java.lang.reflect.Proxy.invoke(Proxy.java:1006) at $Proxy2.activityStopped(Unknown Source) at android.app.servertransaction.PendingTransactionActions$StopInfo.run(PendingTransactionActions.java:144) at android.os.Handler.handleCallback(Handler.java:873) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:207) at android.app.ActivityThread.main(ActivityThread.java:6878) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876) 问题分析 1 Intent 传递的数据过大。 2 onSaveInstance 保存的数据过大。 解决方案 尽可能的使用少量的数据。 大数据考虑持久化和其他传递形式。","link":"/blog/2021/06/18/Problems%E4%B8%93%E9%A2%98%E4%B9%8BParcel/"},{"title":"Problems专题：Provider","text":"Problems专题：Provider0x01 FileProvider：Failed to find configured root that contains /…/**.jpeg123456789101112131415161718192021java.lang.IllegalArgumentException: Failed to find configured root that contains /storage/emulated/0/DCIM/Camera/**.jpeg at androidx.core.content.FileProvider$SimplePathStrategy.getUriForFile(FileProvider.java:800) at androidx.core.content.FileProvider.getUriForFile(FileProvider.java:442) at com.luck.picture.lib.tools.PictureFileUtils.parUri(PictureFileUtils.java:533) at com.luck.picture.lib.PictureBaseActivity.startOpenCameraImage(PictureBaseActivity.java:705) at com.luck.picture.lib.PictureSelectorActivity.startCamera(PictureSelectorActivity.java:926) at com.luck.picture.lib.PictureSelectorActivity.onTakePhoto(PictureSelectorActivity.java:1473) at com.luck.picture.lib.adapter.PictureImageGridAdapter.lambda$onBindViewHolder$0$PictureImageGridAdapter(PictureImageGridAdapter.java:155) at com.luck.picture.lib.adapter.-$$Lambda$PictureImageGridAdapter$0EODmJcP4VP0lqmkEhQ1dzLbHi8.onClick(Unknown Source:2) at android.view.View.performClick(View.java:6608) at android.view.View.performClickInternal(View.java:6585) at android.view.View.access$3100(View.java:785) at android.view.View$PerformClick.run(View.java:25921) at android.os.Handler.handleCallback(Handler.java:873) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:201) at android.app.ActivityThread.main(ActivityThread.java:6810) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:873)Back traces end. 问题分析 FileProvider 路径配置文件被互相覆盖 FileProvider 路径配置文件id重复，导致覆盖 解决方案","link":"/blog/2021/12/06/Problems%E4%B8%93%E9%A2%98%E4%B9%8BProvider/"},{"title":"Problems专题：RecyclerView","text":"Problems专题：RecyclerView0x01 Called attach on a child which is not detached12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364java.lang.IllegalArgumentException: Called attach on a child which is not detached: BaseViewHolder{2b241e1 position=12 id=-1, oldPos=-1, pLpos:-1} androidx.recyclerview.widget.RecyclerView{afecb06 VFED..... ......ID 0,0-1080,2055 #7f09236e app:id/recycler_view_xxx}, adapter:com.xxxx.adapter.XxxAdapter@cfc75c7, layout:androidx.recyclerview.widget.LinearLayoutManager@24af7f4, context:com.xxxx.XxxActivity@1ed75e2 at androidx.recyclerview.widget.RecyclerView$5.attachViewToParent(RecyclerView.java:917) at androidx.recyclerview.widget.ChildHelper.attachViewToParent(ChildHelper.java:239) at androidx.recyclerview.widget.RecyclerView.addAnimatingView(RecyclerView.java:1438) at androidx.recyclerview.widget.RecyclerView.animateDisappearance(RecyclerView.java:4377) at androidx.recyclerview.widget.RecyclerView$4.processDisappeared(RecyclerView.java:616) at androidx.recyclerview.widget.ViewInfoStore.process(ViewInfoStore.java:242) at androidx.recyclerview.widget.RecyclerView.dispatchLayoutStep3(RecyclerView.java:4210) at androidx.recyclerview.widget.RecyclerView.dispatchLayout(RecyclerView.java:3864) at androidx.recyclerview.widget.RecyclerView.onLayout(RecyclerView.java:4410) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at android.widget.RelativeLayout.onLayout(RelativeLayout.java:1131) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at androidx.viewpager.widget.ViewPager.onLayout(ViewPager.java:1775) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1829) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1673) at android.widget.LinearLayout.onLayout(LinearLayout.java:1582) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at android.widget.RelativeLayout.onLayout(RelativeLayout.java:1131) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:332) at android.widget.FrameLayout.onLayout(FrameLayout.java:270) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1829) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1673) at android.widget.LinearLayout.onLayout(LinearLayout.java:1582) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:332) at android.widget.FrameLayout.onLayout(FrameLayout.java:270) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1829) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1673) at android.widget.LinearLayout.onLayout(LinearLayout.java:1582) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:332) at android.widget.FrameLayout.onLayout(FrameLayout.java:270) at com.android.internal.policy.DecorView.onLayout(DecorView.java:905) at android.view.View.layout(View.java:22213) at android.view.ViewGroup.layout(ViewGroup.java:6340) at android.view.ViewRootImpl.performLayout(ViewRootImpl.java:3286) at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2757) at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1865) at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:7933) at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1018) at android.view.Choreographer.doCallbacks(Choreographer.java:837) at android.view.Choreographer.doFrame(Choreographer.java:767) at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:1003) at android.os.Handler.handleCallback(Handler.java:883) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:230) at android.app.ActivityThread.main(ActivityThread.java:7951) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:526) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1034) 问题分析 对同一个 position 位置同时进行notifyItemRemoved(position) 和 notifyItemInserted(position) 操作导致。 解决方案 避免同时对同一个位置先 notifyItemRemoved 再 notifyItemInserted，使用 notifyItemChanged。 1adapter?.notifyItemChanged(position) 0x02 RecyclerView设置最大高度、宽度当RecyclerView属性设置为wrap_content+maxHeight时，maxHeight没有效果。 问题分析 当RecyclerView的LayoutManager#isAutoMeasureEnabled()返回true时，RecyclerView高度取决于children view的布局高度，并非取决于RecyclerView自身的测量高度。 解决方案 因此，我们只需要重写LayoutManager的public void setMeasuredDimension(Rect childrenBounds, int wSpec, int hSpec)方法即可为RecyclerView设置最大宽高。 123456789recyclerView.layoutManager = object : LinearLayoutManager(context, RecyclerView.VERTICAL, false) { override fun setMeasuredDimension(childrenBounds: Rect?, wSpec: Int, hSpec: Int) { val height = View.MeasureSpec.getSize(hSpec) val maxHeight = getScreenHeight() * 4 / 5 val realHeight = height.coerceAtMost(maxHeight) val realHeightSpec = View.MeasureSpec.makeMeasureSpec(realHeight, AT_MOST) super.setMeasuredDimension(childrenBounds, wSpec, realHeightSpec) }} 作者：猫爸iYao链接：https://www.jianshu.com/p/0dec79ff70df来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/blog/2021/06/19/Problems%E4%B8%93%E9%A2%98%E4%B9%8BRecyclerView/"},{"title":"Problems专题：ViewPager2","text":"ViewPager20x01 FragmentManager is already executing transactions1234567891011121314151617181920212223242526272829303132333435363738394041424344454647java.lang.IllegalStateException: FragmentManager is already executing transactions at androidx.fragment.app.FragmentManager.ensureExecReady(FragmentManager.java:1778) at androidx.fragment.app.FragmentManager.execSingleAction(FragmentManager.java:1814) at androidx.fragment.app.BackStackRecord.commitNow(BackStackRecord.java:297) at androidx.viewpager2.adapter.FragmentStateAdapter.removeFragment(FragmentStateAdapter.java:464) at androidx.viewpager2.adapter.FragmentStateAdapter.gcFragments(FragmentStateAdapter.java:228) at androidx.viewpager2.adapter.FragmentStateAdapter.restoreState(FragmentStateAdapter.java:569) at androidx.viewpager2.widget.ViewPager2.restorePendingState(ViewPager2.java:350) at androidx.viewpager2.widget.ViewPager2.dispatchRestoreInstanceState(ViewPager2.java:375) at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:3829) at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:3829) at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:3829) at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:3829) at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:3829) at android.view.View.restoreHierarchyState(View.java:18613) at androidx.fragment.app.Fragment.restoreViewState(Fragment.java:573) at androidx.fragment.app.FragmentStateManager.restoreViewState(FragmentStateManager.java:356) at androidx.fragment.app.FragmentManager.moveToState(FragmentManager.java:1189) at androidx.fragment.app.FragmentManager.moveToState(FragmentManager.java:1356) at androidx.fragment.app.FragmentManager.moveFragmentToExpectedState(FragmentManager.java:1434) at androidx.fragment.app.FragmentManager.moveToState(FragmentManager.java:1497) at androidx.fragment.app.FragmentManager.dispatchStateChange(FragmentManager.java:2625) at androidx.fragment.app.FragmentManager.dispatchActivityCreated(FragmentManager.java:2577) at androidx.fragment.app.FragmentController.dispatchActivityCreated(FragmentController.java:247) at androidx.fragment.app.FragmentActivity.onStart(FragmentActivity.java:541) at androidx.appcompat.app.AppCompatActivity.onStart(AppCompatActivity.java:210) at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1392) at android.app.Activity.performStart(Activity.java:7260) at android.app.ActivityThread.handleStartActivity(ActivityThread.java:3009) at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:180) at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:165) at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:142) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:70) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1840) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:207) at android.app.ActivityThread.main(ActivityThread.java:6878) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876) 解决方案 如果在 Fragment 中使用 ViewPager2，那么 FragmentStateAdapter 应该使用 childFragmentManager。将 1FragmentStateAdapter viewPagerAdapter = new FragmentStateAdapter(getActivity().getSupportFragmentManager(), titles); 改为 1FragmentStateAdapter viewPagerAdapter = new FragmentStateAdapter(getChildFragmentManager(), titles); 0x02 ViewPager2+FragmentStateAdapter的notifyDataSetChanged方法失效原因分析： 因为 FragmentStateAdapter 会保存所有Fragment实例，当调用 Adapter.notifyDataSetChanged() 方法时，Fragment 并没有走 onCreate 方法。 解决方案： 方案一（这个方法会导致内存泄漏，不推荐） 在调用 notifyDataSetChanged 之前，清空 FragmentStateAdapter 的 Fragment 列表。 方案二 重写 getItemId() containsItem() 这两个方法，并确保 getItemId() 的值是唯一的。 1234567891011121314151617181920212223242526272829303132override fun createViewPagerAdapter(): RecyclerView.Adapter&lt;*&gt; { val items = items // avoids resolving the ViewModel multiple times return object : FragmentStateAdapter(this) { override fun createFragment(position: Int): PageFragment { val itemId = items.itemId(position) val itemText = items.getItemById(itemId) return PageFragment.create(itemText) } override fun getItemCount(): Int = items.size override fun getItemId(position: Int): Long = items.itemId(position) override fun containsItem(itemId: Long): Boolean = items.contains(itemId) }}/** A very simple collection of items. Optimized for simplicity (i.e. not performance). */class ItemsViewModel : ViewModel() { private var nextValue = 1L private val items = (1..9).map { longToItem(nextValue++) }.toMutableList() fun getItemById(id: Long): String = items.first { itemToLong(it) == id } fun itemId(position: Int): Long = itemToLong(items[position]) fun contains(itemId: Long): Boolean = items.any { itemToLong(it) == itemId } fun addNewAt(position: Int) = items.add(position, longToItem(nextValue++)) fun removeAt(position: Int) = items.removeAt(position) fun createIdSnapshot(): List&lt;Long&gt; = (0 until size).map { position -&gt; itemId(position) } val size: Int get() = items.size private fun longToItem(value: Long): String = &quot;item#$value&quot; private fun itemToLong(value: String): Long = value.split(&quot;#&quot;)[1].toLong()} 0x03 Design assumption violated123456java.lang.IllegalStateException: Design assumption violated. at androidx.viewpager2.widget.ViewPager2.updateCurrentItem(ViewPager2.java:538) at androidx.viewpager2.widget.ViewPager2$4.onAnimationsFinished(ViewPager2.java:518) at androidx.recyclerview.widget.RecyclerView$ItemAnimator.isRunning(RecyclerView.java:13244) at androidx.viewpager2.widget.ViewPager2.onLayout(ViewPager2.java:515) at android.view.View.layout(View.java:15596) 解决方案： 如果重写了 getItemId() containsItem() 这两个方法，确保 getItemId() 的值是唯一的。代码同0x02 0x04 ViewPager2嵌套RecyclerView手势冲突问题 原因分析： 同方向滚动事件被ViewPager2拦截了。 解决方案： 方案一 自定义NestedScrollableHost采用官方提供的自定义 NestedScrollableHost 来包一层 RecyclerView 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import android.content.Contextimport android.util.AttributeSetimport android.view.MotionEventimport android.view.Viewimport android.view.ViewConfigurationimport android.widget.FrameLayoutimport androidx.viewpager2.widget.ViewPager2import androidx.viewpager2.widget.ViewPager2.ORIENTATION_HORIZONTALimport kotlin.math.absoluteValueimport kotlin.math.sign/** * Layout to wrap a scrollable component inside a ViewPager2. Provided as a solution to the problem * where pages of ViewPager2 have nested scrollable elements that scroll in the same direction as * ViewPager2. The scrollable element needs to be the immediate and only child of this host layout. * * This solution has limitations when using multiple levels of nested scrollable elements * (e.g. a horizontal RecyclerView in a vertical RecyclerView in a horizontal ViewPager2). */class NestedScrollableHost : FrameLayout { constructor(context: Context) : super(context) constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) private var touchSlop = 0 private var initialX = 0f private var initialY = 0f private val parentViewPager: ViewPager2? get() { var v: View? = parent as? View while (v != null &amp;&amp; v !is ViewPager2) { v = v.parent as? View } return v as? ViewPager2 } private val child: View? get() = if (childCount &gt; 0) getChildAt(0) else null init { touchSlop = ViewConfiguration.get(context).scaledTouchSlop } private fun canChildScroll(orientation: Int, delta: Float): Boolean { val direction = -delta.sign.toInt() return when (orientation) { 0 -&gt; child?.canScrollHorizontally(direction) ?: false 1 -&gt; child?.canScrollVertically(direction) ?: false else -&gt; throw IllegalArgumentException() } } override fun onInterceptTouchEvent(e: MotionEvent): Boolean { handleInterceptTouchEvent(e) return super.onInterceptTouchEvent(e) } private fun handleInterceptTouchEvent(e: MotionEvent) { val orientation = parentViewPager?.orientation ?: return // Early return if child can't scroll in same direction as parent if (!canChildScroll(orientation, -1f) &amp;&amp; !canChildScroll(orientation, 1f)) { return } if (e.action == MotionEvent.ACTION_DOWN) { initialX = e.x initialY = e.y parent.requestDisallowInterceptTouchEvent(true) } else if (e.action == MotionEvent.ACTION_MOVE) { val dx = e.x - initialX val dy = e.y - initialY val isVpHorizontal = orientation == ORIENTATION_HORIZONTAL // assuming ViewPager2 touch-slop is 2x touch-slop of child val scaledDx = dx.absoluteValue * if (isVpHorizontal) .5f else 1f val scaledDy = dy.absoluteValue * if (isVpHorizontal) 1f else .5f if (scaledDx &gt; touchSlop || scaledDy &gt; touchSlop) { if (isVpHorizontal == (scaledDy &gt; scaledDx)) { // Gesture is perpendicular, allow all parents to intercept parent.requestDisallowInterceptTouchEvent(false) } else { // Gesture is parallel, query child if movement in that direction is possible if (canChildScroll(orientation, if (isVpHorizontal) dx else dy)) { // Child can scroll, disallow all parents to intercept parent.requestDisallowInterceptTouchEvent(true) } else { // Child cannot scroll, allow all parents to intercept parent.requestDisallowInterceptTouchEvent(false) } } } } }} 对应的layout代码： 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:orientation=&quot;vertical&quot;&gt;... 水平 &lt;androidx.viewpager2.integration.testapp.NestedScrollableHost android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;8dp&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/first_rv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#FFFFFF&quot; /&gt; &lt;/androidx.viewpager2.integration.testapp.NestedScrollableHost&gt; ... 竖直 &lt;androidx.viewpager2.integration.testapp.NestedScrollableHost android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginRight=&quot;20dp&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_weight=&quot;1&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/second_rv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#FFFFFF&quot; /&gt; &lt;/androidx.viewpager2.integration.testapp.NestedScrollableHost&gt;&lt;/LinearLayout&gt; 方案二 自定义RecyclerView自定义 NestedRecyclerView 的分发事件通过 requestDisallowInterceptTouchEvent() 方法来限制父布类的拦截事件 1234567891011121314151617181920212223242526272829303132333435363738394041public class NestedRecyclerView extends RecyclerView { public NestedRecyclerView(@NonNull Context context) { super(context); } public NestedRecyclerView(@NonNull Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public NestedRecyclerView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } private int startX, startY; @Override public boolean dispatchTouchEvent(MotionEvent ev) { switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: startX = (int) ev.getX(); startY = (int) ev.getY(); getParent().requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int endX = (int) ev.getX(); int endY = (int) ev.getY(); int disX = Math.abs(endX - startX); int disY = Math.abs(endY - startY); if (disX &gt; disY) { getParent().requestDisallowInterceptTouchEvent(canScrollHorizontally(startX - endX)); } else { getParent().requestDisallowInterceptTouchEvent(canScrollVertically(startX - endX)); } break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: getParent().requestDisallowInterceptTouchEvent(false); break; } return super.dispatchTouchEvent(ev); }} 方法三 使用ViewPager降级，使用 ViewPager 来嵌套 RecyclerView ，可以避免事件冲突，亲测有效。 0x05 ViewPager2两边保留上一页预览1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import android.os.Bundleimport android.view.LayoutInflaterimport android.view.ViewGroupimport android.widget.Toastimport androidx.fragment.app.FragmentActivityimport androidx.recyclerview.widget.RecyclerViewimport androidx.viewpager2.widget.ViewPager2class PreviewPagesActivity : FragmentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_viewpager2) findViewById&lt;ViewPager2&gt;(R.id.view_pager).apply { // Set offscreen page limit to at least 1, so adjacent pages are always laid out offscreenPageLimit = 1 val recyclerView = getChildAt(0) as RecyclerView recyclerView.apply { clipToPadding = false val leftPadding = resources.getDimensionPixelOffset(R.dimen.halfPageMargin) + resources.getDimensionPixelOffset(R.dimen.peekOffset) // setting padding on inner RecyclerView puts overscroll effect in the right place // TODO: expose in later versions not to rely on // getChildAt(0) which might break setPadding(leftPadding, 0, leftPadding, 0) } adapter = Adapter() } } class ViewHolder(parent: ViewGroup) : RecyclerView.ViewHolder( LayoutInflater.from(parent.context).inflate(R.layout.item_preview_pages, parent, false) ) class Adapter : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() { override fun getItemCount(): Int { return 10 } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { return ViewHolder(parent) } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { holder.itemView.tag = position holder.itemView.setOnClickListener { Toast.makeText(it.context, &quot;position=$position&quot;, Toast.LENGTH_LONG).show() } } }}","link":"/blog/2021/06/20/Problems%E4%B8%93%E9%A2%98%E4%B9%8BViewPager2/"},{"title":"Problems专题：编译环境","text":"Problems专题：编译环境0x01 java.lang.AssertionError: Could not delete caches dir CreateProcess error=206, El nombre del archivo o la extensión es demasiado largo Caused by: java.lang.AssertionError: Could not delete caches dir YourProjectPath\\build\\kotlin\\compileDebugTestingKotlin 临时解决 打开任务管理器，结束 java.exe 或者 OpenJDK Platform Binary 降级 Android Studio Notice: This happens with the newer AndroidStudio 4.2.x. Google hasn’t provide us a fix, so you’ll need to downgrade to an older version which works for you. 4.1.3 seems to be working fine. 参考链接：https://stackoverflow.com/questions/65832868/caused-by-java-lang-assertionerror-could-not-delete-caches-dir-yourproject-bui 0x02 Please close other application using ADB:Monitor, DDMS, Eclip Warning:debug info can be unavailable. Please close other application using ADB:Monitor, DDMS, Eclipse. 方案一： 1$ adb usb 方案二： 打开任务管理器，结束adb.exe进程。 方案三： 重启 adb 服务 12$ adb kill-server$ adb start-server 0x03 真机偶现能安装apk但是Logcat无法查看log即使重启Android studio，重启adb服务都无法解决。最后通过重启手机搞定","link":"/blog/2021/06/20/Problems%E4%B8%93%E9%A2%98%E4%B9%8B%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"},{"title":"Python爬取网络图片","text":"直接上源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455'''用Python爬某新闻网站的照片PS:仅测试爬虫功能，滥用后果自负'''import requestsfrom hashlib import md5import reimport osWEB_URL = 'https://new.qq.com/omn/20200207/20200207A0OSQX00.html'IMAGE_PATH='/Users/**/workspaces/pythonP/img1'# 通过正则找出网页中所有的图片地址def find_img_url(): r = requests.get(WEB_URL) r.raise_for_status() r.encoding = r.apparent_encoding demo = r.text list = [] # &quot;.*?&quot; ：正则表达式匹配任意字符串 pattern1 = '&lt;img src=&quot;.*?&quot; class=&quot;content-picture&quot;&gt;' results1 = re.findall(pattern1, demo) for res1 in results1: # &lt;img src=&quot;//inews.gtimg.com/newsapp_bt/0/11299639206/1000&quot; class=&quot;content-picture&quot;&gt; # https://inews.gtimg.com/newsapp_bt/0/11299639205/1000 res1 = res1.replace('&lt;img src=\\&quot;','https:') res1 = res1.replace('\\&quot; class=\\&quot;content-picture\\&quot;&gt;','') list.append(res1) # print(res1) pattern2 = '\\&quot;http://inews.gtimg.com/newsapp_bt/0/.*?/1000\\&quot;' results2 = re.findall(pattern2, demo) for res2 in results2: res2 = res2.replace('\\&quot;','') list.append(res2) # print(res2) return list# 下载图片到本地def download_image(img_url): r = requests.get(img_url) r.raise_for_status() content = r.content file_path = '{0}/{1}.{2}'.format(IMAGE_PATH, md5(content).hexdigest(), 'jpg') # print(file_path) if not os.path.exists(file_path):#os.path.exists(file_path)判断文件是否存在，存在返回1，不存在返回0 with open(file_path, 'wb') as f: f.write(content) f.close()list = find_img_url()for i in list: print(i, ' download...') download_image(i)print(&quot;一共下载{}条数据！&quot;.format(len(list)))","link":"/blog/2020/02/08/Python%E7%88%AC%E5%8F%96%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87/"},{"title":"RecyclerView+SnapHelper实现ViewPager滑动效果","text":"RecyclerView+SnapHelper实现ViewPager滑动效果SnapHelper结合RecyclerView使用，能很方便的实现ViewPager滑动效果。SnapHelper是一个抽象类，Google内置了两个默认实现类，LinearSnapHelper和PagerSnapHelper。 LinearSnapHelper的使用方法使当前Item居中显示，常用场景是横向的RecyclerView, 类似ViewPager效果，但是又可以快速滑动多个条目。 12345LinearLayoutManager manager = new LinearLayoutManager(getContext());manager.setOrientation(LinearLayoutManager.HORIZONTAL);recyclerView.setLayoutManager(manager);LinearSnapHelper snapHelper = new LinearSnapHelper();snapHelper.attachToRecyclerView(recyclerView); PagerSnapHelper的使用方法使RecyclerView像ViewPager一样的效果，每次只能滑动一页。 12345LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this);linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);recyclerView.setLayoutManager(linearLayoutManager);PagerSnapHelper snapHelper = new PagerSnapHelper();snapHelper.attachToRecyclerView(recyclerView); 原文地址：https://developer.aliyun.com/article/665537","link":"/blog/2023/06/28/RecyclerView+SnapHelper%E5%AE%9E%E7%8E%B0ViewPager%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/"},{"title":"RecyclerViewHelper","text":"RecyclerViewHelper提供了注册加载更多，和判断是否不足一屏等工具方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import androidx.recyclerview.widget.GridLayoutManagerimport androidx.recyclerview.widget.LinearLayoutManagerimport androidx.recyclerview.widget.RecyclerViewimport androidx.recyclerview.widget.StaggeredGridLayoutManagerobject RecyclerViewHelper { /** * RecyclerView 注册加载更多监听 */ @JvmStatic fun addOnScrollListener(recyclerView: RecyclerView, loadMore: () -&gt; Unit) { recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() { override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) { super.onScrollStateChanged(recyclerView, newState) if (newState == RecyclerView.SCROLL_STATE_IDLE) { val layoutManager = recyclerView.layoutManager if (layoutManager is LinearLayoutManager) { val lastPosition = layoutManager.findLastCompletelyVisibleItemPosition() val count = layoutManager.itemCount if (lastPosition &gt;= count - 2) { loadMore() return@onScrollStateChanged } } else if (layoutManager is StaggeredGridLayoutManager) { val spanCount = layoutManager.spanCount val count = layoutManager.itemCount val result = IntArray(spanCount) layoutManager.findLastCompletelyVisibleItemPositions(result) for (it in result) { if (it &gt;= count - spanCount - 1) { loadMore() return@onScrollStateChanged } } } else if (layoutManager is GridLayoutManager) { val spanCount = layoutManager.spanCount val count = layoutManager.itemCount val lastPosition = layoutManager.findLastCompletelyVisibleItemPosition() if (lastPosition &gt;= count - spanCount - 1) { loadMore() return@onScrollStateChanged } } } } }) } /** * 判断是否一屏显示 * * 错误或者空了返回 false */ @JvmStatic fun isOneScreen(recyclerView: RecyclerView?): Boolean { recyclerView?.let { val layoutManager = recyclerView.layoutManager if (layoutManager is LinearLayoutManager) { // include GridLayoutManager val count = layoutManager.itemCount return count &gt; 0 &amp;&amp; layoutManager.findFirstCompletelyVisibleItemPosition() == 0 &amp;&amp; layoutManager.findLastCompletelyVisibleItemPosition() == count - 1 } else if (layoutManager is StaggeredGridLayoutManager) { val spanCount = layoutManager.spanCount val count = layoutManager.itemCount val last = IntArray(spanCount) val first = IntArray(spanCount) layoutManager.findLastCompletelyVisibleItemPositions(last) layoutManager.findFirstCompletelyVisibleItemPositions(first) return count &gt; 0 &amp;&amp; first.min() == 0 &amp;&amp; last.max() == count - 1 } } return false } private fun IntArray.min(): Int { if (this.isNotEmpty()) { var result = this[0] this.forEach { if (result &gt; it) result = it } return result } return -1 } private fun IntArray.max(): Int { if (this.isNotEmpty()) { var result = this[0] this.forEach { if (result &lt; it) result = it } return result } return -1 }}","link":"/blog/2021/08/23/RecyclerViewHelper/"},{"title":"RecyclerView实现瀑布流以及细节问题","text":"RecyclerView实现瀑布流以及细节问题1）使用 StaggeredGridLayoutManager 12345678910val layoutManager = StaggeredGridLayoutManager(2, RecyclerView.VERTICAL)layoutManager.gapStrategy = StaggeredGridLayoutManager.GAP_HANDLING_NONE// 禁止左右交换recyclerView.layoutManager = layoutManager// decorationrecyclerView.addItemDecoration(StaggeredDividerItemDecoration(16, true))// adaptermAdapter = PjListVPAdapter()recyclerView.adapter = mAdapter// animatorrecyclerView.itemAnimator = DefaultItemAnimator() 2）如果需要Item之间的间隔，就需要自定义 ItemDecoration 1234567891011121314151617181920212223242526272829303132333435363738/** * 瀑布流ItemDecoration * 必须配合RecyclerView的StaggeredGridLayoutManager一起使用 * * @author Dench * @data 2020-09-04 */class StaggeredDividerItemDecoration( space: Int, // 间隔 pix private val includeEdge: Boolean = false // 是否显示边距) : ItemDecoration() { private val space = TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, space.toFloat(), Resources.getSystem().displayMetrics ).toInt() override fun getItemOffsets( outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State ) { val lp = view.layoutParams as StaggeredGridLayoutManager.LayoutParams val lm = parent.layoutManager as StaggeredGridLayoutManager val spanIndex: Int = lp.spanIndex val spanCount: Int = lm.spanCount if (includeEdge) { outRect.left = space * (spanCount - spanIndex) / spanCount outRect.right = space * (spanIndex + 1) / spanCount outRect.top = space } else { outRect.left = space * spanIndex / spanCount outRect.right = space * (spanCount - spanIndex - 1) / spanCount outRect.bottom = space } }} 3）滑动时闪烁，Item自动切换位置 解决方案 layoutManager.setGapStrategy(StaggeredGridLayoutManager.GAP_HANDLING_NONE) 4）设置了 GAP_HANDLING_NONE 属性之后，顶端空白 由于ViewHolder的回收机制，滑回到上方时Item需要重新自行绘制，因为item的尺寸并不确定，导致重新绘制之后跟原来的高度不一致，又禁止了左右切换的调整策略，才导致的顶端空白。通常是因为加载图片之后重新计算item高度导致，尽可能在load图片之前先确定ImageView的高度。这个时候只能给后台同学提需求了，在服务的Json数据需要包含图片的长宽信息。附根据屏幕计算ImageView显示的宽高 1234567private val width = (DensityUtil.getScreenWidth() - TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, 68f,// 间距和padding Resources.getSystem().displayMetrics).toInt()) / 2 // spanCountprivate val height = (width * 1.5).toInt()imageView.layoutParams.height = height 5）刷新，删除，插入同样会导致顶端空白 使用 notifyDataSetChanged()方法做刷新时，会触发StaggeredGridLayoutManager 的onItemsChanged 方法，导致item的spanIndex重现进行计算，item所在列的位置出现了变化，导致了顶部空白。 使用notifyItemRangeInserted，notifyItemRangeChanged做局部刷新 则不会引起变化。 6）注意item等宽问题 采用StaggeredDividerItemDecoration的等宽计算方法。","link":"/blog/2020/09/04/RecyclerView%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%E4%BB%A5%E5%8F%8A%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/"},{"title":"RecyclerView 根据滑动位置动态改变背景透明度","text":"RecyclerView 根据滑动位置动态改变背景透明度根据滑动位置动态改变背景透明度,直接上代码： 1234567891011121314151617181920212223242526272829303132333435363738binding.recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() { override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) { super.onScrolled(recyclerView, dx, dy) onRecyclerScrolled(recyclerView, dx, dy) } override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) { super.onScrollStateChanged(recyclerView, newState) }})private val dp180 = dp2px(180)private var distanceY = 0private var current = 0private fun onRecyclerScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) { distanceY += dy when { distanceY &gt;= dp180 -&gt; { if (current == 1) return recyclerView.setBackgroundColor(Color.argb(255, 246, 248, 250)) current = 1 } distanceY &lt;= 0 -&gt; { if (current == 0) return recyclerView.setBackgroundColor(Color.argb(0, 246, 248, 250)) current = 0 } else -&gt; { recyclerView.setBackgroundColor( Color.argb( distanceY * 255 / dp180, 246, 248, 250 ) ) current = -1 } }}","link":"/blog/2022/06/27/RecyclerView%E6%A0%B9%E6%8D%AE%E6%BB%91%E5%8A%A8%E4%BD%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E6%94%B9%E5%8F%98%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E5%BA%A6/"},{"title":"RecyclerView滑动到指定Item并置顶","text":"RecyclerView滑动到指定Item并置顶0x01 TopLinearSmoothScroller123456789101112import android.content.Contextimport androidx.recyclerview.widget.LinearSmoothScrollerclass TopLinearSmoothScroller(context: Context?) : LinearSmoothScroller(context) { public override fun getVerticalSnapPreference(): Int { return SNAP_TO_START } override fun getHorizontalSnapPreference(): Int { return SNAP_TO_START }} 0x02 TopScrollLinearLayoutManager1234567891011121314151617import android.content.Contextimport androidx.recyclerview.widget.LinearLayoutManagerimport androidx.recyclerview.widget.RecyclerViewclass TopScrollLinearLayoutManager(context: Context?, orientation: Int, reverseLayout: Boolean) : LinearLayoutManager(context, orientation, reverseLayout) { override fun smoothScrollToPosition( recyclerView: RecyclerView?, state: RecyclerView.State?, position: Int ) { val linearSmoothScroller = TopLinearSmoothScroller(recyclerView?.context) linearSmoothScroller.targetPosition = position startSmoothScroll(linearSmoothScroller) }} 0x03 RecyclerView中使用设置recyclerView的layoutManager为自定义的TopScrollLinearLayoutManager，然后直接调用 smoothScrollToPosition() 方法就可以滚动到指定的位置并且置顶了。 1234567recyclerView.layoutManager = TopScrollLinearLayoutManager( this, LinearLayoutManager.HORIZONTAL, false)// ...recyclerView.smoothScrollToPosition(1)","link":"/blog/2023/03/24/RecyclerView%E6%BB%9A%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9Aitem%E5%B9%B6%E7%BD%AE%E9%A1%B6/"},{"title":"RecyclerView Item 嵌套 ScrollView","text":"RecyclerView Item 嵌套 ScrollViewRecyclerView Item 嵌套 ScrollView 产生 Touch 事件冲突，通过自定义ScrollView来拦截和处理事件 自定义 ItemScrollView 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import android.content.Contextimport android.util.AttributeSetimport android.view.MotionEventimport android.widget.ScrollViewclass ItemScrollView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : ScrollView(context, attrs, defStyleAttr) { override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { parent.requestDisallowInterceptTouchEvent(true) return super.onInterceptTouchEvent(ev) } private var lastY: Float = 0f override fun onTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -&gt; { lastY = ev.y } MotionEvent.ACTION_MOVE -&gt; { val currentY = ev.y this.scrollBy(0, (lastY - currentY).toInt()) lastY = currentY } MotionEvent.ACTION_UP -&gt; { lastY = 0f } } return canScroll() } private fun canScroll(): Boolean { val child = getChildAt(0) child?.let { return height &lt; child.height } return false }}","link":"/blog/2021/06/17/RecyclerView%E7%9A%84item%E5%B5%8C%E5%A5%97ScrollView/"},{"title":"RecyclerView的几种Decoration","text":"RecyclerView的几种Decoration1234567891011121314151617181920212223242526272829303132333435363738394041import android.content.res.Resourcesimport android.graphics.Rectimport android.util.TypedValueimport android.view.Viewimport androidx.recyclerview.widget.RecyclerViewclass SimplePaddingDecoration( spaceDp: Int, val orientation: Int = RecyclerView.VERTICAL) : RecyclerView.ItemDecoration() { private val dividerHeight: Int = TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, spaceDp.toFloat(), Resources.getSystem().displayMetrics ).toInt() override fun getItemOffsets( outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State ) { val position = (view.layoutParams as RecyclerView.LayoutParams).viewLayoutPosition if (orientation == RecyclerView.VERTICAL) { // 竖直 if (position + 1 != parent.adapter?.itemCount) { outRect.set(0, 0, 0, dividerHeight) } else { outRect.set(0, 0, 0, 0) } } else { // 水平 if (position + 1 != parent.adapter?.itemCount) { outRect.set(0, 0, dividerHeight, 0) } else { outRect.set(0, 0, 0, 0) } } }}","link":"/blog/2021/06/17/RecyclerView%E7%9A%84%E5%87%A0%E7%A7%8DDecoration/"},{"title":"Sublime Text3 Shortcuts（mac)","text":"Shortcuts Action command+return 在当前行后插入新行 command+shift+return 在当前行前插入新行 command+control+up&amp;down 交换上下行 command+shift+D 复制（多）行 control+shift+K 删除行 command+L 选择行 command+/ 注释 command+] 向右缩进 command+[ 向左缩进 command+F 查找 command+option+F 替换 command+B 编译 control+G 跳转到行","link":"/blog/2020/02/09/SublimeText%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"Terminal设置代理","text":"0x01 Terminal代理设置给终端terminal设置代理 12345$ vim ~/.zshrc## proxyexport http_proxy=http://127.0.0.1:8001export https_proxy=$http_proxy$ source ~/.zshrc 0x02 AndroidStudio代理设置Android Studio 的代理设置 Perference --&gt; Appearance &amp; Behavior --&gt; System Settings --&gt; Http Proxy 0x03 Gradle代理设置gradle代理可以配置在： 环境变量GRADLE_USER_HOME指定的gradle系统目录默认路径\\Users\\Xxx\\.gradle\\gradle.properties 项目根目录gradle.properties 前者优先级更高。 123456systemProp.http.proxyHost=127.0.0.1systemProp.http.proxyPort=1080systemProp.https.proxyHost=127.0.0.1systemProp.https.proxyPort=1080systemProp.socks.proxyHost=127.0.0.1systemProp.socks.proxyPort=1080 0x04 配置代理用户名和密码1234567891011121314# Project-wide Gradle settings....systemProp.http.proxyHost=proxy.company.comsystemProp.http.proxyPort=443systemProp.http.proxyUser=usernamesystemProp.http.proxyPassword=passwordsystemProp.http.auth.ntlm.domain=domainsystemProp.https.proxyHost=proxy.company.comsystemProp.https.proxyPort=443systemProp.https.proxyUser=usernamesystemProp.https.proxyPassword=passwordsystemProp.https.auth.ntlm.domain=domain... 0x05 过滤代理对于国内的仓库可以不走代理，还有部分内网地址也可以不走代理 123systemProp.http.nonProxyHosts=developer.huawei.com|maven.aliyun.com|192.168.*systemProp.https.nonProxyHosts=developer.huawei.com|maven.aliyun.com|192.168.*systemProp.socks.nonProxyHosts=developer.huawei.com|maven.aliyun.com|192.168.* 0x06 修改gradle.properties配置1org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=10808","link":"/blog/2021/05/27/Terminal%E5%92%8CAndroidStudio%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"},{"title":"Vim入门 - Vim Tutor","text":"第一讲小结 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。h (左移) j (下行) k (上行) l (右移) 欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 &lt;回车&gt; 欲退出 Vim 编辑器，请输入 `&lt;ESC&gt;` :q! `&lt;回车&gt;` 放弃所有改动。 `&lt;ESC&gt;` :wq `&lt;回车&gt;` 保存改动。 在正常模式下删除光标所在位置的字符，请按： x 欲插入或添加文本，请输入： i 输入欲插入文本 `&lt;ESC&gt;` 在光标前插入文本 I 输入欲插入文本 `&lt;ESC&gt;` 在一行前插入文本 a 输入欲添加文本 `&lt;ESC&gt;` 在光标后添加文本 A 输入欲添加文本 `&lt;ESC&gt;` 在一行后添加文本 特别提示：按下 &lt;ESC&gt; 键会带您回到正常模式或者撤消一个不想输入或部分完整的命令。 第二讲小结 欲从当前光标删除至下一个单词，请输入：dw 欲从当前光标删除至当前行末尾，请输入：d$ 欲删除整行，请输入：dd 欲重复一个动作，请在它前面加上一个数字：2w 在正常模式下修改命令的格式是： operator [number] motion其中： operator - 操作符，代表要做的事情，比如 d 代表删除 [number] - 数字，代表动作重复的次数 motion - 动作，代表在所操作的文本上的移动 w 后面一个word W 后面一个WORD b 前面一个word B 前面一个WROD e 代表单词末尾(end) ge 前面一个单词 0 行首 $ 行末 gg 文档首 G 文档尾 欲移动光标到行首，请按数字0键：0 欲撤消以前的操作，请输入：u (小写的u)欲撤消在一行中所做的改动，请输入：U (大写的U)欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 第三讲小结 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。 更改类命令的格式是： c [number] motion 第四讲小结 CTRL-G 用于显示当前光标所在位置和文件状态信息。G 用于将光标跳转至文件最后一行。先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。gg 用于将光标跳转至文件第一行。 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。 如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/old/new/gc 第五讲小结 :!command 用于执行一个外部命令 command。 请看一些实际例子：(MS-DOS) (Unix):!dir :!ls - 用于显示当前目录的内容。:!del FILENAME :!rm FILENAME - 用于删除名为 FILENAME 的文件。 :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。 v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 第六讲小结 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 O 可以在光标上方打开新的一行。 输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 A 可以在光标所在行的行末之后插入文本。 e 命令可以使光标移动到单词末尾。 操作符 y 复制文本，p 粘贴先前复制的文本。 输入大写的 R 将进入替换模式，直至按 &lt;ESC&gt; 键回到正常模式。 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下：‘ic’ ‘ignorecase’ 查找时忽略字母大小写‘is’ ‘incsearch’ 查找短语时显示部分匹配‘hls’ ‘hlsearch’ 高亮显示所有的匹配短语选项名可以用完整版本，也可以用缩略版本。 在选项前加上 no 可以关闭选项： :set noic 第七讲小结 输入 :help 或者按 &lt;F1&gt; 键或 &lt;Help&gt; 键可以打开帮助窗口。 输入 :help cmd 可以找到关于 cmd 命令的帮助。 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。 输入 :q 以关闭帮助窗口 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。按 &lt;TAB&gt; 可以使用一个补全。","link":"/blog/2020/02/17/VimTutor/"},{"title":"Vim 升级和配置","text":"1. Vim 升级1brew install vim --with-lua --with-override-system-vim 以后想更新 vim 版本，直接输入 brew upgrade vim 。 2. 配置自己的 .vimrc 文件1234567set nu &quot; 显示行号set showcmd &quot; 显示输入的命令set ruler &quot; 显示标尺syntax on &quot; 自动语法高亮set nobackup &quot; 不自动备份set hlsearch &quot; 搜索高亮set vb t_vb= &quot; 没有错误提示音 3. vundle 管理插件3.1 安装1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 3.2 配置插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647set nocompatible &quot; be iMproved, requiredfiletype off &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()&quot; alternatively, pass a path where Vundle should install plugins&quot;call vundle#begin('~/some/path/here')&quot; let Vundle manage Vundle, requiredPlugin 'VundleVim/Vundle.vim'&quot; The following are examples of different formats supported.&quot; Keep Plugin commands between vundle#begin/end.&quot; plugin on GitHub repoPlugin 'altercation/vim-colors-solarized'Plugin 'Lokaltog/vim-powerline'Plugin 'octol/vim-cpp-enhanced-highlight'Plugin 'Raimondi/delimitMate'&quot; plugin from http://vim-scripts.org/vim/scripts.html&quot; Plugin 'L9'&quot; Git plugin not hosted on GitHubPlugin 'git://git.wincent.com/command-t.git'&quot; git repos on your local machine (i.e. when working on your own plugin)Plugin 'file:///home/gmarik/path/to/plugin'&quot; The sparkup vim script is in a subdirectory of this repo called vim.&quot; Pass the path to set the runtimepath properly.Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}&quot; Install L9 and avoid a Naming conflict if you've already installed a&quot; different version somewhere else.&quot; Plugin 'ascenator/L9', {'name': 'newL9'}&quot; All of your Plugins must be added before the following linecall vundle#end() &quot; requiredfiletype plugin indent on &quot; required&quot; To ignore plugin indent changes, instead use:&quot;filetype plugin on&quot;&quot; Brief help&quot; :PluginList - lists configured plugins&quot; :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache&quot; :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal&quot;&quot; see :h vundle for more details or wiki for FAQ&quot; Put your non-Plugin stuff after this line 123456&quot; 配色方案&quot;set background=dark&quot;colorscheme solarized&quot; 设置状态栏主题风格let g:Powerline_colorscheme='solarized256' 3.3 插件管理命令123:PluginInstall:PluginClean :PluginUpdate","link":"/blog/2020/02/19/Vim%E5%8D%87%E7%BA%A7%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"title":"Vim 编程实践","text":"1. 基础设置1234567891011121314&quot;显示行set nu&quot; 设置屏幕滚动时在光标上下方保留5行预览代码set so=5&quot; 设置debug为 zdnnoremap zd :action Debug&lt;CR&gt;&quot; 设置run 为 zrnnoremap zr :action Run&lt;CR&gt;&quot; 插入模式下 jk 映射 Escinoremap jk &lt;Esc&gt; 2. 导航和查找hjkl 光标在屏幕文本中的移动 w 后面一个word W 后面一个WORD b 前面一个word B 前面一个WROD e 代表单词末尾(end) ge 前面一个单词 0 行首 $ 行末 gg 文档首 G 文档尾 :&lt;行号&gt; or &lt;行号&gt;G or &lt;行号&gt;gg - 快速定位到行 &lt;行号&gt;&lt;回车&gt; - 往下跳转行数 &lt;行号&gt;[j/k] - 往下、往上跳转行数 2.1 查找fa - 查找该行从光标位置首次出现a的位置/text - 查找text，按n健查找下一个，按N健查找前一个。?text - 查找text，反向查找，按n健查找下一个，按N健查找前一个。% - 括号匹配vim中有一些特殊字符在查找时需要转义 .*[]^%/?~$ 2.2 替换ra - 将当前字符替换为a，当期字符即光标所在字符。s/old/new/ - 用old替换new，替换当前行的第一个匹配s/old/new/g - 用old替换new，替换当前行的所有匹配%s/old/new/ - 用old替换new，替换所有行的第一个匹配%s/old/new/g - 用old替换new，替换整个文件的所有匹配:10,20 s/^/ /g - 在第10行知第20行每行前面加四个空格，用于缩进。 2.3 滚屏C-B - 滚动屏幕上一屏 C-F - 滚动屏幕下一屏 Ctrl + F 屏幕向下滚动一屏Ctrl + B 屏幕向上滚动一屏Ctrl + E 屏幕向下滚动一行Ctrl + Y 屏幕向上滚动一行Ctrl + D 屏幕向下滚动半屏Ctrl + U 屏幕向上滚动半屏 3. 编辑o - 在当前行下方插入新行并自动缩进 O - 在当前行上方插入新行并自动缩进 i - 在当前字符左方开始插入字符 a - 在当前字符右方开始插入字符 I - 光标移动到行首并进入插入模式 A - 光标移动到行尾并进入插入模式 s - 删除光标所在字符并进入插入模式 S - 删除光标所在行并进入插入模式 r - 修改光标所在字符，然后返回普通模式 R - 进入覆盖模式 p - 粘贴 3.1 范围指令c&lt;范围&gt; - 删除光标所在位置周围某个范围的文本并进入插入模式。 常用的组合有：caw - 删除一个单词包括它后面的空格并开始插入；ciw - 删除一个单词并开始插入；ci” - 删除一个字符串内部文本并开始插入；ct字符 − 从光标位置删除本行某个字符之前（保留该字符）并开始插入；C − 删除光标位置到行尾的内容并进入插入模式(相当于c$) d&lt;范围&gt; - 删除一定范围内的文本 y&lt;范围&gt; - 将范围内的文本放入0号和”号注册栏 v&lt;范围&gt; - 选择范围内的文本 =&lt;范围&gt; - 自动缩进范围内的文本 gU&lt;范围&gt; - 将范围内的字符转换为大写 gu&lt;范围&gt; - 将范围内的字符转换为小写 3.2 范围$ - 从光标位置到行尾 ^ - 从光标位置到行首，不包含缩进空白 0 - 从光标位置到行首，包含缩进空白 gg - 从光标位置到文件开头 G - 从光标位置到文件结尾 % - 从光标位置到另一边匹配的括号 f&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符 F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符 t&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符 T&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符 &lt;空格&gt; - 光标所在位置 (gU空格 表示将光标位置字符转为大写) 范围 a &amp; ia 可理解为“一个”, i 可理解为 in. aw - 一个单词加一个空格 iw - 一个单词 a” - 一个字符串包括双引号 i” - 一个字符串内部文本 a&lt; - 一组&lt; &gt;包含的文本，包括&lt; &gt;号本身 i&lt; - 一组&lt; &gt;内部文本 同理类推： a[, i[, a(, i(, a{, i{ 3.3 对光标所在行操作。dd 删除一行 yy 复制一行 cc 删除一行文本并开始插入 == 自动缩进当前行 &gt;&gt; 当前行缩进一格 &lt;&lt; 当前行减少缩进 4. 常用命令daw 删除一个单词ndd 删除当前行之后的n行xp 交换当前字符和其后一个字符ddp 交换行yyp 复制行ci” 删除””内的字符串并插入ca{ 删除{}内容并插入，包含{}本身:1,10d 删除1-10行,利用p命令可将剪切后的内容进行粘贴:1,$d 删除所有行J 删除两行之间的空行，实际上是合并两行P 在当前行前粘贴:1,10 co 20 将1-10行插入到第20行之后:1,$ co $ 将整个文件复制一份并添加到文件尾部:1, 10 m 20 将第1-10行移动到第20行之后","link":"/blog/2020/03/14/Vim%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"},{"title":"Windows 上配置 Git SSH","text":"Windows 上配置 Git SSHhttps://support.atlassian.com/bitbucket-cloud/docs/set-up-an-ssh-key/ 0x01 Set up SSH for Git on WindowsUse this section to create a default identity and SSH key when you’re using Git on Windows. By default, the system adds keys for all identities to the /Users/&lt;username&gt;/.ssh directory. Step 1. Set up your default identityFrom the command line, enter ssh-keygen. ssh-keygen -t rsa -b 4096 -C &quot;email&quot; List the contents of .ssh to view the key files. 12$ dir .ssh id_rsa id_rsa.pub Step 2. Add the key to the ssh-agentIf you don’t want to type your password each time you use the key, you’ll need to add it to the ssh-agent. 12$ eval $(ssh-agent) $ ssh-add ~/.ssh/id_rsa Step 3. Add the public key to your Account settingsOpen your .ssh/id_rsa.pub file and copy its contents. From Bitbucket, Paste the copied public key into the SSH Key field. Click Save. Step 4. Test connectionReturn to the command line and verify your configuration and username by entering the following command: 1$ ssh -T git@bitbucket.org 0x02 Working with non-default SSH key pair pathsIf you used a non-default file path for your GitLab SSH key pair,you must configure your SSH client to find your GitLab SSH private keyfor connections to your GitLab server (perhaps gitlab.com). For OpenSSH clients this is configured in the ~/.ssh/config file.Below are two example host configurations using their own key: 123456789# GitLab.com serverHost gitlab.comRSAAuthentication yesIdentityFile ~/.ssh/config/private-key-filename-01# Private GitLab serverHost gitlab.company.comRSAAuthentication yesIdentityFile ~/.ssh/config/private-key-filename 0x03 使用ed25519方式生成SSH秘钥如果使用rsa加密方式，出现秘钥无效，依旧提示输入用户名密码验证，请通过ed25519加密方式，生成ssh秘钥。 ssh-keygen -t ed25519 -C &quot;email&quot; -b 4096 对应生成的私钥 id_ed25519 和公钥 id_ed25519.pub, 其他配置步骤同rsa生成方式一致。","link":"/blog/2022/06/20/Windows%E4%B8%8A%E9%85%8D%E7%BD%AESSH/"},{"title":"ZSH &amp; iTerm2 的最佳实现","text":"ZSH &amp; iTerm2 的最佳实现 最终效果 0x01 安装 iTerm 2iTerm 2 官网: https://www.iterm2.com/ 0x02 设置字体安装 powerline 字体, 适配 Agnoster 主题 Powerline Font Github : https://github.com/powerline/fonts 在iTerm 2 设置 powerline 字体，个人喜欢 Source Code Pro for Powerline 。 0x03 设置颜色方案Solarized Github: https://github.com/altercation/solarized 在 iTerm 2 已经预安装了 Solarized 配色方案，在 color 配色方案选择 Solarized Dark 。 完了可以选择一张背景图片，并设置合适的透明度。 0x04 安装 oh-my-zshmac os 预装了 zsh,切换 shell : 1chsh -s $(which zsh) oh my zsh 官网:https://github.com/ohmyzsh/ohmyzsh oh-my-zsh 的安装： 1234# curlsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;# or wgetsh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; bash 的环境变量配置文件 ~/.bash_profile , 而 zsh 的环境变量配置文件是 ~/.zshrc。 0x05 agnoster 主题oh my zsh 官方为用户提供了上百种主题，在 ~/.zshrc 文件中配置主题: 1ZSH_THEME=&quot;agnoster&quot; Agnoster 官网: https://github.com/agnoster/agnoster-zsh-theme 测试字体是否支持 1$ echo &quot;\\ue0b0 \\u00b1 \\ue0a0 \\u27a6 \\u2718 \\u26a1 \\u2699&quot; 路径前缀太长的问题，在 ~/.oh-my-zsh/themes 路径下找到 agnoster.zsh-theme 文件，将里面的 build_prompt 下的 prompt_context 字段，注释掉即可。 0x06 oh-my-zsh插件配置在 ~/.zshrc 文件中配置插件: 1plugins=(autojump sublime osx zsh-syntax-highlighting git-dw) 1. 推荐插件 autojumpj 是 autojump 命令的简写 j: 快速跳转 jo: 快速打开 ps: 需要安装autojump的mac平台插件配合使用 2. 推荐插件 osx ofd: 用 Finder 打开当前目录 cdf: cd 到当前 Finder 目录 pfd: 打印当前 Finder 路径 pfs: 打印当前 Finder 选择的文件路径 3. 推荐插件 git gl: git pull gs: git status ga: git add gaa: git add –all gc: git commit gcm: git commit -m gp: git push gb: git branch gba: git branch -a gbd: git branch -d gco: git checkout 4. 推荐插件 sublime st: 用 Sublime Text 打开文件 stt: 用 Sublime Text 打开当前目录 sst: sudo st，用于编辑系统文件 find_project: 从当前目录往上(parent directory)查找 sublime, git 工程 create_project: 创建 sublime 工程 0x07 自定义插件由于 zsh 推荐的插件 git 有一些别名比较难记，所以考虑自定义一个插件 git-dw 。 1. 创建 git-dw.plugin.zsh 文件在 ~/.oh-my-zsh/custom/plugins/ 创建 /git-dw/git-dw.plugin.zsh 。 2. 自定义别名编辑 git-dw.plugin.zsh 文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102## Aliases#alias g='git'alias ga='git add'alias gaa='git add --all'alias gb='git branch'alias gba='git branch -a'alias gbd='git branch -d'alias gbD='git branch -D'alias gc='git commit'alias gcm='git commit -m'alias gc!='git commit --amend'# alias gcam='git commit -a -m'# alias gcsm='git commit -s -m'alias gco='git checkout'alias gcob='git checkout -b'alias gcf='git config --list'# alias gcl='git clone --recurse-submodules'# alias gclean='git clean -id'# alias gpristine='git reset --hard &amp;&amp; git clean -dfx'alias gf='git fetch'alias gfap='git fetch --all --prune'alias ggpull='git pull origin &quot;$(git_current_branch)&quot;'alias ggpush='git push origin &quot;$(git_current_branch)&quot;'alias gh='git help'alias gl='git pull'# alias glr='git pull --rebase'# alias glrv='git pull --rebase -v'# alias glra='git pull --rebase --autostash'# alias glrav='git pull --rebase --autostash -v'# alias glum='git pull upstream master'alias gm='git merge'# alias gmom='git merge origin/master'# alias gmt='git mergetool --no-prompt'# alias gmtvim='git mergetool --no-prompt --tool=vimdiff'# alias gmum='git merge upstream/master'# alias gma='git merge --abort'alias gp='git push'alias gr='git remote'alias grv='git remote -v'alias gra='git remote add'alias grmv='git remote rename'alias grrm='git remote remove'alias grset='git remote set-url'# alias grb='git rebase'# alias grba='git rebase --abort'# alias grbc='git rebase --continue'# alias grbd='git rebase develop'# alias grbi='git rebase -i'# alias grbm='git rebase master'# alias grbs='git rebase --skip'# alias grev='git revert'# alias grh='git reset'# alias grhh='git reset --hard'# alias groh='git reset origin/$(git_current_branch) --hard'# alias grm='git rm'# alias grmc='git rm --cached'# alias grs='git restore'# alias grss='git restore --source'# alias grt='cd &quot;$(git rev-parse --show-toplevel || echo .)&quot;'# alias gru='git reset --'# alias grup='git remote update'# alias grv='git remote -v'alias gs='git status'alias gst='git stash'# alias gstaa='git stash apply'# alias gstc='git stash clear'# alias gstd='git stash drop'# alias gstl='git stash list'# alias gstp='git stash pop'# alias gsts='git stash show --text'# alias gstall='git stash --all'# alias gsu='git submodule update'# alias gsw='git switch'# alias gswc='git switch -c'alias gt='git tag'# alias gts='git tag -s'# alias gtv='git tag | sort -V' 3. 自定义方法123456789# Pretty log messagesfunction _git_log_prettily(){ if ! [ -z $1 ]; then git log --pretty=$1 fi}compdef _git _git_log_prettily=git-log... 4. 添加 README.md5. 应用插件在 ~/.zshrc 文件中应用插件: 1plugins=(... git-dw) 现在你重启 shell 就可以看到结果了。 0x08 配置环境变量在 ~/.zshrc 文件最顶部添加: 1export PATH=/Users/**/Library/Android/sdk/platform-tools:$PATH","link":"/blog/2020/02/11/ZSH%E5%92%8CiTerm2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E7%8E%B0/"},{"title":"mac快捷键常用键盘符号","text":"符号 键位 ⌘ command ⌃ control ⌥ option ⇧ shift ↩ return ⌫ delete","link":"/blog/2020/02/09/mac%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%B8%B8%E7%94%A8%E9%94%AE%E7%9B%98%E7%AC%A6%E5%8F%B7/"},{"title":"Vim 入门","text":"1. Vim 入门资料1.1 vim 的 tutor终端直接输入：vimtutor 1.2 vim manual/usr/share/vim/vim81/doc 1.3 github vim 入门到精通Vim 从入门到精通: https://github.com/wsdjeg/vim-galore-zh_cn 2. Vim 入门首个目标 把jk映射成。具体指令为inoremap jk &lt;Esc&gt;。这条是最重要的一条。设置完这条之后几乎马上就可以体会到vim的好处了。可以试试用^$移动到行首行末，用w移动到单词结尾，ddp交换上下两行位置，yyp复制当前行，gg跳到文件开头，G跳到文件结尾，gd跳到定义，/def跳到下个函数开始的地方。用cw修改当前单词，用cf.直接修改到下个.号。用ci(直接修改括号里的内容。写代码时，每当写完一段有小停顿，习惯性按下jk进入normal模式。 不要折腾vim插件，直接用vim。我的建议是将你原来使用的ide中的vim插件打开就行了。不要浪费太多时间在快捷键的配置上。目前对我来说jk到esc就是全部需要的配置，在可见的未来我也准备用ctrl+c或者ctrl+[替换掉jk。 适应面向搜索编程的思想。我个人感觉vim快最重要的原因就是精准选择。而实现精准选择的必要途径就是搜索。搜索是vim的核心。比如说你需要跳到下个函数，那直接/def。再比如需要跳到括号末，直接f)。终端中，刚输入完python eval.py device cuda data.batch_size 256，发现这行指令中的python要改成python3，可以 直接Fna3。又发现前面要加sudo，直接^isudo。总之一切精确修改都是通过搜索来完成的，这与我们不使用vim编程时搜索只用来查找代码有本质区别。 精确跳转+可视化模式。掌握精确跳转后，结合v V ctrl+v 这三种可视化模式进行精确选择，配合cdyrp等指令，可以完成极其灵活的代码增删改查。到这一步你会发现vim对你编程速度的提高已经是革命性的了。","link":"/blog/2020/02/14/vim%E5%85%A5%E9%97%A8/"},{"title":"多线程编程","text":"多线程编程0x01 生产者和消费者问题1.BlockingQueue 阻塞队列实现123456789101112131415161718192021222324252627// 生产者class Producer implements Runnable { private final BlockingQueue&lt;Integer&gt; queue; public Producer(BlockingQueue queue) { this.queue = queue; } @Override public void run() { while (true) { try { queue.put(produce()); System.out.println(Thread.currentThread().getName() + &quot; put a message, total = &quot; + queue.size()); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } } } private int produce() { int x = (int) (Math.random() * 10); System.out.println(Thread.currentThread().getName() + &quot; put: &quot; + x); return x; }} 1234567891011121314151617181920212223// 消费者class Consumer implements Runnable { private final BlockingQueue&lt;Integer&gt; queue; Consumer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { System.out.println(Thread.currentThread().getName() + &quot; take...&quot;); consume(queue.take()); } } catch (InterruptedException ex) { ex.printStackTrace(); } } void consume(int x) { System.out.println(Thread.currentThread().getName() + &quot; take a message :&quot; + x + &quot;, total = &quot; + queue.size()); }} 1234567891011public static void main(String[] args) { BlockingQueue&lt;Integer&gt; blockingQueue = new LinkedBlockingDeque&lt;&gt;(3); Producer cooker = new Producer(blockingQueue); Consumer waiter = new Consumer(blockingQueue); ExecutorService s = Executors.newFixedThreadPool(5); s.submit(cooker); s.submit(cooker); s.submit(cooker); s.submit(waiter); s.submit(waiter);} 2.使用Object的wait/notify方法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class 消费者模式2 { public static void main(String[] args) { WorkBench wb = new WorkBench(); Waiter waiter = new Waiter(wb); Cooker cooker = new Cooker(wb); new Thread(cooker, &quot;厨师1号&quot;).start(); new Thread(cooker, &quot;厨师2号&quot;).start(); new Thread(cooker, &quot;厨师3号&quot;).start(); new Thread(waiter, &quot;服务员1号&quot;).start(); new Thread(waiter, &quot;服务员2号&quot;).start(); }}// 生产者：厨师 -&gt; 做菜class Cooker implements Runnable { WorkBench wb; public Cooker(WorkBench wb) { this.wb = wb; } @Override public void run() { while (true) { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } wb.put(); } }}// 消费者：服务员 -&gt; 取菜class Waiter implements Runnable { WorkBench wb; public Waiter(WorkBench wb) { this.wb = wb; } @Override public void run() { while (true) { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } wb.take(); } }}// 产品队列：（类似 BlockingQueue）class WorkBench { public static final int MAX = 3; private volatile int queue = 0; public synchronized void put() { while (queue &gt;= MAX) { System.out.println(String.format(&quot;%s waiting...&quot;, Thread.currentThread().getName())); try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } queue++; System.out.println(String.format(&quot;%s put()一盘菜,队列还有%d盘菜&quot;, Thread.currentThread().getName(), queue)); notifyAll(); } public synchronized void take() { while (queue &lt;= 0) { System.out.println(String.format(&quot;%s waiting...&quot;, Thread.currentThread().getName())); try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } queue--; System.out.println(String.format(&quot;%s take()一盘菜,队列还剩%d盘菜&quot;, Thread.currentThread().getName(), queue)); notifyAll(); }} 3.使用ReentrantLock的await/signal实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import java.util.Random;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class 消费者模式3 { public static void main(String[] args) { WorkBench wb = new WorkBench(); Waiter waiter = new Waiter(wb); Cooker cooker = new Cooker(wb); new Thread(cooker, &quot;厨师1号&quot;).start(); new Thread(cooker, &quot;厨师2号&quot;).start(); new Thread(cooker, &quot;厨师3号&quot;).start(); new Thread(waiter, &quot;服务员1号&quot;).start(); new Thread(waiter, &quot;服务员2号&quot;).start(); }}// 生产者：厨师 -&gt; 做菜class Cooker implements Runnable { WorkBench wb; public Cooker(WorkBench wb) { this.wb = wb; } @Override public void run() { while (true) { try { Thread.sleep(new Random().nextInt(3000)); } catch (InterruptedException e) { e.printStackTrace(); } wb.put(); } }}// 消费者：服务员 -&gt; 取菜class Waiter implements Runnable { WorkBench wb; public Waiter(WorkBench wb) { this.wb = wb; } @Override public void run() { while (true) { try { Thread.sleep(new Random().nextInt(2000)); } catch (InterruptedException e) { e.printStackTrace(); } wb.take(); } }}// 产品队列：（类似 BlockingQueue）class WorkBench { public static final int MAX = 4; private volatile int queue = 0; private final ReentrantLock lock = new ReentrantLock(); final Condition full = lock.newCondition(); final Condition empty = lock.newCondition(); public void put() { lock.lock(); while (queue &gt;= MAX) { System.out.println(String.format(&quot;%s waiting...&quot;, Thread.currentThread().getName())); try { full.await(); } catch (InterruptedException e) { e.printStackTrace(); } } queue++; System.out.println(String.format(&quot;%s put()一盘菜,队列还有%d盘菜&quot;, Thread.currentThread().getName(), queue)); empty.signalAll(); lock.unlock(); } public void take() { lock.lock(); while (queue &lt;= 0) { System.out.println(String.format(&quot;%s waiting...&quot;, Thread.currentThread().getName())); try { empty.await(); } catch (InterruptedException e) { e.printStackTrace(); } } queue--; System.out.println(String.format(&quot;%s take()一盘菜,队列还剩%d盘菜&quot;, Thread.currentThread().getName(), queue)); full.signalAll(); lock.unlock(); }} 0x02 多线程打印ABCD题目描述: 有4个线程和1个公共的字符数组。线程1的功能就是向数组输出A，线程2的功能就是向字符输出B，线程3的功能就是向数组输出C，线程4的功能就是向数组输出D。要求按顺序向数组赋值ABCDABCDABCD，ABCD的个数由线程函数1的参数指定。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.Scanner;public class PrintABCD { public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNext()) { int n = in.nextInt(); startPrintABCD(n); } } public static void startPrintABCD(int n) { sb = new StringBuffer(); Object a = new Object(); Object b = new Object(); Object c = new Object(); Object d = new Object(); Thread t1 = new Thread(new Task(n, a, b, 'A', 0)); Thread t2 = new Thread(new Task(n, b, c, 'B', 1)); Thread t3 = new Thread(new Task(n, c, d, 'C', 2)); Thread t4 = new Thread(new Task(n, d, a, 'D', 3)); t1.start(); t2.start(); t3.start(); t4.start(); try { t1.join(); t2.join(); t3.join(); t4.join(); System.out.println(sb.toString()); // System.out.println(sb.length()); } catch (InterruptedException e) { e.printStackTrace(); } } private static StringBuffer sb; static class Task implements Runnable { int n; Object self, target; char ch; int id; public Task(int n, Object self, Object target, char ch, int id) { this.n = n; this.self = self; this.target = target; this.ch = ch; this.id = id; } @Override public void run() { // System.out.println(&quot;Task&quot; + id + &quot; run...&quot;); while (n-- &gt; 0) { synchronized (self) { while (sb.length() % 4 != id) { waitSelf(); } sb.append(ch); notifyTarget(); waitSelf(); } } notifyTarget(); // System.out.println(&quot;Task&quot; + id + &quot; stop...&quot;); } private void waitSelf() { try { self.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } private void notifyTarget() { synchronized (target) { target.notify(); } } }}","link":"/blog/2020/08/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"title":"哲学启蒙","text":"哲学启蒙人们的烦恼，基本是源于读书太少，而想得太多。 读哲学，不只是去吸收大家们的思想，而是在读的同时不要忘记思考。 哲学也许给不了人成功，也不一定会带来富有，但至少获得了自由。 大问题作者: [美国] 罗伯特·C. 所罗门 哲学的故事作者：威尔·杜兰特 用讲故事的方法，介绍了主要哲学家的生平及其观点，从苏格拉底、柏拉图、亚里士多德到叔本华、尼采再到柏格森，罗素、杜威等。在阐述每位哲学家思想的同时，生动地介绍了他们生活的时代背景、生活境遇和情感经历。 苏菲的世界作者：乔斯坦·贾德 14岁的少女苏菲不断接到一些极不寻常的来信，世界像谜团一般在她眼底展开，她在一位神秘导师的指引下，运用少女天生的悟性与后天知识，企图解开这些谜团，然而。事实真相远比她所想的更怪异、更离奇…… 西方哲学简史作者：伯特兰·罗素 记述了从西方哲学萌芽的古希腊哲学一直到二十世纪早期期西方哲学的发展历程。 《西方哲学简史》是在罗素的代表作《西方哲学史》的基础上，保留原著架构，并对一些繁复的逻辑论证进行通俗化的基础上编译而成，使其更加适合普通读者阅读。 禅与摩托车维修艺术作者：罗伯特·M.波西格 1968年，他与长子克里斯一起骑着摩托车从双子城出发，在中西部旷野、落基山区和西海岸从事心灵探险。他之所以开始这场横跨美国大陆的万里长旅，是希望从狭窄而受限的自我解脱。一路经过复杂经验与反省思考，他终于找到生理上的、精神上的完整与清净。 霍金高评： 时间简史霍金 你的第一本哲学书作者：托马斯·内格尔","link":"/blog/2021/05/30/%E5%93%B2%E5%AD%A6%E5%90%AF%E8%92%99/"},{"title":"大量文本的浏览进度和浏览时长统计","text":"大量文本的浏览进度和浏览时长统计埋点需求，Android App 需要在onResume 和 onPause 方法中计算浏览的时长，同时上报浏览的进度。 浏览进度Rate具体的计算方式的具体过程： 1、在滚动屏幕过程中，通过 textContent?.viewTreeObserver?.addOnScrollChangedListener 来记录屏幕滚动的位置 2、在滚动监听里通过textContent?.getLocationOnScreen(location)获取在屏幕的具体位置，同时， 计算出visibleHeight = screenHeight - location[1] 当前文本的可见高度 3、当可见高度超过目标的高度，则认为已经全部浏览，rate = 100% ，同时移除滚动监听textContent?.viewTreeObserver?.removeOnScrollChangedListener(mScrollChangeListener) 核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243private var totalHeight: Int = 0private var visibleHeight: Int = 0private var screenHeight = 0fun getViewRate(): String? =if (totalHeight &lt;= 0 || visibleHeight &lt; 0) nullelse &quot;${(visibleHeight * 100 / totalHeight)}%&quot;private fun bindViewTreeObserver() { cleanCache() contentTv.post { totalHeight = contentTv.height screenHeight = ScreenUtils.getScreenHeight(context) contentVisibleRate() } contentTv.viewTreeObserver.addOnScrollChangedListener(mScrollChangeListener)}private fun cleanCache() { totalHeight = 0 screenHeight = 0 visibleHeight = 0}private val mScrollChangeListener = ViewTreeObserver.OnScrollChangedListener { contentVisibleRate()}private fun contentVisibleRate() { val location = IntArray(2) contentTv.getLocationOnScreen(location) visibleHeight = (screenHeight - location[1]).coerceAtLeast(visibleHeight) if (visibleHeight &gt;= totalHeight) { visibleHeight = totalHeight removeOnScrollChangedListener() }}private fun removeOnScrollChangedListener() { mScrollChangeListener?.let { contentTv.viewTreeObserver.removeOnScrollChangedListener(mScrollChangeListener) }}","link":"/blog/2021/09/09/%E5%A4%A7%E9%87%8F%E6%96%87%E6%9C%AC%E7%9A%84%E6%B5%8F%E8%A7%88%E8%BF%9B%E5%BA%A6%E5%92%8C%E6%B5%8F%E8%A7%88%E6%97%B6%E9%95%BF%E7%BB%9F%E8%AE%A1/"},{"title":"如何阅读一本书","text":"如何阅读一本书 读书是一件快乐的事 阅读的三要素 控制时间 抓重点 有深度 1. 检视阅读（泛读）1.1 有系统的略读 时间控制在5-15分钟 先看书名 研究目录页 通篇略读或者重点略读 顺序：书名、序、目录、内容、附录 通篇略读：快速从头到尾读一遍，不要停，不要进入细节 重点略读：选几个和主题相关的篇章来看 或者 随意翻翻 2. 分析阅读（精读）2.1 时间控制在3天以内（不包括数学，计算机类的工具书）2.2 抓重点 找关键字 找关键句 找关键段落 找关键章节 2.3 动手用工具做笔记、列大纲 边看边列 结构图或者思维导图 大纲可以先粗略，后细化 3. 总结评论 这本书讲的是什么？ 用一句话（最简洁的话）概括一本书的内容 这本书的主旨和和论述是什么？ 适当的参考别人的总结和评论 这本书的内容真实吗？ 真正理解才能评论，最能学习的读者，也就是最能批评的读者 不同意的观点要理性表达 分享和讨论 这本书和我有什么关系？ 4.常见问题读书慢的解决办法： 检视阅读 控制时间 运用基本的快速阅读方法 阅读时没有共鸣和尿点 这本书跟你的关系 结合你自己的经历和经验 放弃还没有共鸣的书 读书时追求完美，辛苦到死 抓重点 正确的阅读流程 控制时间 看完了一本书，书还是书，我还是我 总结和实践 做笔记","link":"/blog/2020/02/04/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"},{"title":"StatusBarHelper","text":"StatusBarHelperStatusBar 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950object StatusBarHelper { /** * 内容显示在状态栏下面（LAYOUT_FULLSCREEN） &gt; 6.0 * true:白底黑字,false:黑底白字 */ fun fitSystemBar(activity: Activity, light: Boolean = true) { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) return val window = activity.window val decorView = window.decorView var visibility = decorView.systemUiVisibility visibility = visibility or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE visibility = if (light) { visibility or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR } else { visibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv() } decorView.systemUiVisibility = visibility window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) window.statusBarColor = Color.TRANSPARENT } /** * 调整状态栏文字、图标颜色 &gt; 6.0 * true:白底黑字,false:黑底白字 */ fun lightStatusBar(activity: Activity, light: Boolean = true) { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) return var window: Window = activity.window var visibility = window.decorView.systemUiVisibility visibility = if (light) { visibility or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR } else { visibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv() } window.decorView.systemUiVisibility = visibility } // 获取状态栏高度 fun getStatusBarHeight(activity: Activity): Int { var result: Int = 0 var resId = activity.resources.getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;) if (resId &gt; 0) result = activity.resources.getDimensionPixelOffset(resId) return result }} 默认statusbar 高度 24dp（不同版本可能不一样）。如果设置内容显示在状态栏下面，需要在相应的布局设置android:fitsSystemWindows=&quot;true&quot;，系统会为该布局自动添加一个statusbar高度的topPadding。 SystemBar隐藏/显示模式123456var options: Int = View.SYSTEM_UI_FLAG_FULLSCREEN // hide status bar | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN // make content behind status bar | View.SYSTEM_UI_FLAG_LAYOUT_STABLE // keep layout stable | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // hide navigation bar | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION // make content behind navigation bar | View.SYSTEM_UI_FLAG_IMMERSIVE // immersive mode","link":"/blog/2020/08/23/%E5%B7%A5%E5%85%B7%E7%B1%BB-StatusBarHelper/"},{"title":"SystemBarUtil 工具类","text":"SystemBarUtil 工具类工具类，提供了系统栏高度和屏幕宽高获取方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import android.app.Activityimport android.content.Contextimport android.graphics.Pointimport android.os.Buildimport android.view.Viewimport android.view.ViewGroupimport android.view.WindowManager/*** 工具类，提供了系统栏高度和屏幕宽高获取方法*/object SystemBarUtil { /** * 获取状态栏高度 */ @JvmStatic fun getStatusBarHeight(context: Context): Int { var height = 0 try { val resourceId = context.applicationContext.resources.getIdentifier( &quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot; ) if (resourceId &gt; 0) { height = context.applicationContext.resources.getDimensionPixelSize(resourceId) } } catch (e: Exception) { } return height } /** * 获取系统导航栏高度 */ @JvmStatic fun getNavigationBarHeight(context: Context): Int { var height = 0 try { val resourceId = context.applicationContext.resources.getIdentifier( &quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot; ) if (resourceId &gt; 0) { height = context.applicationContext.resources.getDimensionPixelSize(resourceId) } } catch (e: Exception) { } return height } private const val NAVIGATION = &quot;navigationBarBackground&quot; // 该方法需要在View完全被绘制出来之后调用 @JvmStatic private fun isNavigationBarVisible(activity: Activity): Boolean { val vp = activity.window.decorView as ViewGroup? if (vp != null) { for (i in 0 until vp.childCount) { vp.getChildAt(i).context.packageName if (vp.getChildAt(i).id !== View.NO_ID &amp;&amp; NAVIGATION == activity.resources.getResourceEntryName(vp.getChildAt(i).id) ) { return true } } } return false } /** * 获取屏幕的物理大小 px */ @JvmStatic fun getDeviceScreenSize(context: Context): Point { val appContext = context.applicationContext val wm = appContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager val point = Point(0, 0) if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) { wm.defaultDisplay.getRealSize(point) } else { wm.defaultDisplay.getSize(point) } return point } /** * 获取显示屏幕的宽高 px */ @JvmStatic fun getDisplaySize(context: Context): Point { val point = Point(0, 0) val dm = context.applicationContext.resources.displayMetrics point.x = dm.widthPixels point.y = dm.heightPixels return point }}","link":"/blog/2023/02/15/%E5%B7%A5%E5%85%B7%E7%B1%BB-SystemBarUtil/"},{"title":"SettingsHelper","text":"SettingsHelperSettingsHelper 自启动设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208import android.content.ComponentNameimport android.content.Contextimport android.content.Intentimport android.net.Uriimport android.os.Buildimport android.provider.Settingsimport android.util.Log/** * 跳转自启动页面 */object AutoStartHelper { private val hashMap = mutableMapOf&lt;String, List&lt;String&gt;&gt;().apply { put( &quot;Xiaomi&quot;, listOf( &quot;com.miui.securitycenter/com.miui.permcenter.autostart.AutoStartManagementActivity&quot;, &quot;com.miui.securitycenter&quot; ) ) put( &quot;samsung&quot;, listOf( &quot;com.samsung.android.sm_cn/com.samsung.android.sm.ui.ram.AutoRunActivity&quot;, &quot;com.samsung.android.sm_cn/com.samsung.android.sm.ui.appmanagement.AppManagementActivity&quot;, &quot;com.samsung.android.sm_cn/com.samsung.android.sm.ui.cstyleboard.SmartManagerDashBoardActivity&quot;, &quot;com.samsung.android.sm_cn/.ui.ram.RamActivity&quot;, &quot;com.samsung.android.sm_cn/.app.dashboard.SmartManagerDashBoardActivity&quot;, &quot;com.samsung.android.sm/com.samsung.android.sm.ui.ram.AutoRunActivity&quot;, &quot;com.samsung.android.sm/com.samsung.android.sm.ui.appmanagement.AppManagementActivity&quot;, &quot;com.samsung.android.sm/com.samsung.android.sm.ui.cstyleboard.SmartManagerDashBoardActivity&quot;, &quot;com.samsung.android.sm/.ui.ram.RamActivity&quot;, &quot;com.samsung.android.sm/.app.dashboard.SmartManagerDashBoardActivity&quot;, &quot;com.samsung.android.lool/com.samsung.android.sm.ui.battery.BatteryActivity&quot;, &quot;com.samsung.android.sm_cn&quot;, &quot;com.samsung.android.sm&quot; ) ) put( &quot;HUAWEI&quot;, listOf( &quot;com.huawei.systemmanager/.startupmgr.ui.StartupNormalAppListActivity&quot;, &quot;com.huawei.systemmanager/.appcontrol.activity.StartupAppControlActivity&quot;, &quot;com.huawei.systemmanager/.optimize.process.ProtectActivity&quot;, &quot;com.huawei.systemmanager/.optimize.bootstart.BootStartActivity&quot;, // &quot;com.huawei.systemmanager/com.huawei.permissionmanager.ui.MainActivity&quot;, // 这个是隐私-权限管理，但是没有自启动权限！！！ &quot;com.android.settings/com.android.settings.Settings$&quot; + &quot;AppAndNotificationDashboardActivity&quot;, // 鸿蒙系统，应用和服务，列表中有应用启动管理 &quot;com.huawei.systemmanager&quot; ) ) put( &quot;vivo&quot;, listOf( &quot;com.iqoo.secure/.ui.phoneoptimize.BgStartUpManager&quot;, &quot;com.vivo.permissionmanager/.activity.BgStartUpManagerActivity&quot;, &quot;com.vivo.permissionmanager/.activity.SoftPermissionDetailActivity&quot;, &quot;com.iqoo.secure/.safeguard.PurviewTabActivity&quot;, &quot;com.iqoo.secure&quot;, &quot;com.vivo.permissionmanager&quot; ) ) put( &quot;Meizu&quot;, listOf( &quot;com.meizu.safe/.permission.SmartBGActivity&quot;, &quot;com.meizu.safe/.permission.PermissionMainActivity&quot;, &quot;com.meizu.safe&quot; ) ) put( &quot;OPPO&quot;, listOf( &quot;com.coloros.safecenter/.startupapp.StartupAppListActivity&quot;, &quot;com.coloros.safecenter/.permission.startup.StartupAppListActivity&quot;, &quot;com.oppo.safe/.permission.startup.StartupAppListActivity&quot;, &quot;com.coloros.oppoguardelf/com.coloros.powermanager.fuelgaue.PowerUsageModelActivity&quot;, &quot;com.coloros.safecenter/com.coloros.privacypermissionsentry.PermissionTopActivity&quot;, &quot;com.coloros.safecenter&quot;, &quot;com.oppo.safe&quot;, &quot;com.coloros.oppoguardelf&quot; ) ) put( &quot;oneplus&quot;, listOf( &quot;com.oneplus.security/.chainlaunch.view.ChainLaunchAppListActivity&quot;, &quot;com.oneplus.security&quot; ) ) put( &quot;letv&quot;, listOf( &quot;com.letv.android.letvsafe/.AutobootManageActivity&quot;, &quot;com.letv.android.letvsafe/.BackgroundAppManageActivity&quot;, &quot;com.letv.android.letvsafe&quot; ) ) put( &quot;zte&quot;, listOf( &quot;com.zte.heartyservice/.autorun.AppAutoRunManager&quot;, &quot;com.zte.heartyservice&quot; ) ) //金立 put( &quot;F&quot;, listOf( &quot;com.gionee.softmanager/.MainActivity&quot;, &quot;com.gionee.softmanager&quot; ) ) //以下为未确定(厂商名也不确定) put( &quot;smartisanos&quot;, listOf( &quot;com.smartisanos.security/.invokeHistory.InvokeHistoryActivity&quot;, &quot;com.smartisanos.security&quot; ) ) //360 put( &quot;360&quot;, listOf( &quot;com.yulong.android.coolsafe/.ui.activity.autorun.AutoRunListActivity&quot;, &quot;com.yulong.android.coolsafe&quot; ) ) //360 put( &quot;ulong&quot;, listOf( &quot;com.yulong.android.coolsafe/.ui.activity.autorun.AutoRunListActivity&quot;, &quot;com.yulong.android.coolsafe&quot; ) ) //酷派 put( &quot;coolpad&quot; /*厂商名称不确定是否正确*/, listOf( &quot;com.yulong.android.security/com.yulong.android.seccenter.tabbarmain&quot;, &quot;com.yulong.android.security&quot; ) ) //联想 put( &quot;lenovo&quot; /*厂商名称不确定是否正确*/, listOf( &quot;com.lenovo.security/.purebackground.PureBackgroundActivity&quot;, &quot;com.lenovo.security&quot; ) ) put( &quot;htc&quot; /*厂商名称不确定是否正确*/, listOf( &quot;com.htc.pitroad/.landingpage.activity.LandingPageActivity&quot;, &quot;com.htc.pitroad&quot; ) ) //华硕 put( &quot;asus&quot; /*厂商名称不确定是否正确*/, listOf( &quot;com.asus.mobilemanager/.MainActivity&quot;, &quot;com.asus.mobilemanager&quot; ) ) //酷派 put( &quot;YuLong&quot;, listOf( &quot;com.yulong.android.softmanager/.SpeedupActivity&quot;, &quot;com.yulong.android.security/com.yulong.android.seccenter.tabbarmain&quot;, &quot;com.yulong.android.security&quot; ) ) } fun startAutoBootSetting(context: Context?) { Log.e(&quot;AutoStartHelper&quot;, &quot;当前手机型号为：&quot; + Build.MANUFACTURER) var result = false run start0@{ for ((manufacturer, componentNameList) in hashMap) { if (Build.MANUFACTURER.equals(manufacturer, ignoreCase = true)) { for (actName in componentNameList) { try { var intent: Intent? = null if (actName.contains(&quot;/&quot;)) { intent = Intent() intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) intent.component = ComponentName.unflattenFromString(actName) if (actName.contains(&quot;SoftPermissionDetailActivity&quot;)) { intent.putExtra(&quot;packagename&quot;, context?.packageName) } } // else { // // 跳转到对应的安全管家/安全中心 // intent = context?.packageManager?.getLaunchIntentForPackage(actName) // } intent?.let { context?.startActivity(intent) result = true return@start0 } } catch (e: Exception) { e.printStackTrace() } } } } } if (!result) { try { // 跳转到app详情设置 val intent = Intent() intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK intent.action = Settings.ACTION_APPLICATION_DETAILS_SETTINGS intent.data = Uri.fromParts(&quot;package&quot;, context?.packageName, null) context?.startActivity(intent) } catch (e: Exception) { e.printStackTrace() } } }","link":"/blog/2022/01/07/%E5%B7%A5%E5%85%B7%E7%B1%BB-%E8%87%AA%E5%90%AF%E5%8A%A8%E8%AE%BE%E7%BD%AE/"},{"title":"打开手机自带的应用商店","text":"需求背景：因为各种原因，需要打开手机自带的应用商店 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142import android.content.Contextimport android.content.Intentimport android.net.Uriobject MarketUtils { const val XIAOMI_MARKET = &quot;com.xiaomi.market&quot; const val HUAWEI_MARKET = &quot;com.huawei.appmarket&quot; const val OPPO_MARKET = &quot;com.oppo.market&quot; const val OPPO_MARKET2 = &quot;com.heytap.market&quot; const val VIVO_MARKET = &quot;com.bbk.appstore&quot; const val MEIZU_MARKET = &quot;com.meizu.mstore&quot; const val YYB_MARKET = &quot;com.tencent.android.qqdownloader&quot; fun startTargetMarket(context: Context, deepLink: String, packageName: String) { //&quot;deeplink&quot;: &quot;market://details?id=com.taobao.taobao&amp;...&quot; try { val uri = Uri.parse(deepLink) val intent = Intent(Intent.ACTION_VIEW, uri) intent.setPackage(packageName) context.startActivity(intent) } catch (e: Exception) { e.printStackTrace() val uri = Uri.parse(deepLink) val intent = Intent(Intent.ACTION_VIEW, uri) context.startActivity(intent) } } /** * 跳转到腾讯应用宝 */ private fun startTencentMarket(context: Context, deepLink: String) { val uri: Uri = Uri.parse(deepLink) // &quot;market://details?id=com.taobao.taobao&amp;...&quot; val intent = Intent(Intent.ACTION_VIEW, uri) intent.setClassName( &quot;com.tencent.android.qqdownloader&quot;, &quot;com.tencent.pangu.link.LinkProxyActivity&quot; ) context.startActivity(intent) }} 测试代码： 123456789101112131415161718192021222324252627private fun initView() { // val deepLink = &quot;market://details?id=com.taobao.taobao&amp;ref=&amp;caller=com.zhongduomei.rrmj.society&amp;token=OWNjY2YyNGNiYzYwYTNkMCMxNjQ5NjQ2NTA0OTA5IzEjY29tLnRhb2Jhby50YW9iYW8jS29iZS8yNEAwZjY1NGI3ZGZlZWJlZWI2NTk3MTkyNWE4ZDFhZTc1Zg==&amp;style=1&amp;m=adapi_2049933&amp;tk_con=eyJ0cmFja0lkIjoiN2VkOGI0ZWM2YjAwN2FmNjkzZDc0ODJkYTBlNzgyMDMiLCJkZXZpY2VJZCI6Ijg2Mzg5NDAzMjE1ODg3NyIsImFwcElkIjoiMjMzNCIsInZlcnNpb25JZCI6IjAiLCJlbnRlcklkIjoiMTQiLCJwYWdlSWQiOiIxMDAwMDEiLCJhYiI6IjFfMF85IiwiYWRJZCI6IjQwNzA2ODY5OCIsInQiOiIxNjQ5NjQ2NTA0OTA3IiwidiI6InYxIn0%3D&amp;tk_ref=%7B%22adId%22%3A%22407068698%22%2C%22trackId%22%3A%227ed8b4ec6b007af693d7482da0e78203%22%7D&quot; xiaomi_market.setOnClickListener { MarketUtils.startTargetMarket(this, deepLink, MarketUtils.XIAOMI_MARKET) } huawei_market.setOnClickListener { MarketUtils.startTargetMarket(this, deepLink, MarketUtils.HUAWEI_MARKET) } oppo_market.setOnClickListener { if (android.os.Build.VERSION.SDK_INT &gt;= 28) { MarketUtils.startTargetMarket(this, deepLink, MarketUtils.OPPO_MARKET2) } else { MarketUtils.startTargetMarket(this, deepLink, MarketUtils.OPPO_MARKET) } } vivo_market.setOnClickListener { MarketUtils.startTargetMarket(this, deepLink, MarketUtils.VIVO_MARKET) } meizu_market.setOnClickListener { MarketUtils.startTargetMarket(this, deepLink, MarketUtils.MEIZU_MARKET) } yyb_market.setOnClickListener { MarketUtils.startTargetMarket(this, deepLink, MarketUtils.YYB_MARKET) }}","link":"/blog/2022/04/13/%E6%89%93%E5%BC%80%E6%89%8B%E6%9C%BA%E8%87%AA%E5%B8%A6%E7%9A%84%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97/"},{"title":"时间管理","text":"时间管理1.远离懒惰2.提高效率 事不宜迟，速度制胜 有时候不是我们做的不够好，而是对手做的比我们更快一步。 统筹安排，平行作业 洗衣，烧水，煮早饭和刷牙可以并行执行 优化流程，简化操作 整理整顿，快速定位 选择效率更高的工具 第一次就把事情做好 3.善用零碎的时间4.充分利用业余时间 学习阅读 独处思考 补充精力 适度的社交和娱乐 注重家庭生活 培养个人兴趣","link":"/blog/2020/02/04/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"},{"title":"Aria下载器源码分析","text":"Aria下载器源码分析Aria 中文文档: https://aria.laoyuyu.me/aria_doc/ 版本：3.8.15 0x01 注册流程在Activity的onCreate、fragment的onCreate、java的构造函数中使用Aria.download(this).register()便可以实现注册。 0x0101 Aria类，下载库的统一入口Aria类仅一个私有的构造方法，无法实例化 1private Aria() {} 0x0102 Aria类的download方法Aria类中的2个主要静态方法 download, upload, 对应下载和上传两种类型 以下载方法为例，下载，在当前类中调用Aria方法，参数需要使用this，返回对象是 DownloadReceiver 123456public static DownloadReceiver download(Object obj) { if (AriaManager.getInstance() != null) { return AriaManager.getInstance().download(obj); } return get(convertContext(obj)).download(obj);} AriaManager是个单例 首次会走get方法，最终执行AriaManager#init()方法进行初始化 convertContext()方法会判断当前参数obj是否是Context对象，并返回Context 最后都会执行AriaManager单例对象的download()方法，返回一个DownloadReceiver对象 0x0103 AriaManager初始化123456789101112131415161718192021222324252627282930@SuppressLint(&quot;StaticFieldLeak&quot;) private static volatile AriaManager INSTANCE = null;private AriaManager(Context context) { APP = context.getApplicationContext();}public static AriaManager getInstance() { return INSTANCE;}static AriaManager init(Context context) { if (INSTANCE == null) { synchronized (LOCK) { if (INSTANCE == null) { INSTANCE = new AriaManager(context); INSTANCE.initData(); } } } return INSTANCE;}private void initData() { mConfig = AriaConfig.init(APP); initDb(APP); regAppLifeCallback(APP); initAria();} init()方法，双空判断加锁实现AriaManager单例 初始化调用 initData() 方法 初始化 AriaConfig 初始化DB 注册APP生命周期回调，Activity销毁自动移除当前对象的receiver Aria初始化，异常处理，日志，命令处理器 CommandManager 初始化 0x0104 AriaManager类的download123456789101112131415161718192021222324private Map&lt;String, AbsReceiver&gt; mReceivers = new ConcurrentHashMap&lt;&gt;();/*** 处理下载操作*/DownloadReceiver download(Object obj) { IReceiver receiver = mReceivers.get(getKey(ReceiverType.DOWNLOAD, obj)); if (receiver == null) { receiver = putReceiver(ReceiverType.DOWNLOAD, obj); } return (receiver instanceof DownloadReceiver) ? (DownloadReceiver) receiver : null;}private IReceiver putReceiver(ReceiverType type, Object obj) { final String key = getKey(type, obj); IReceiver receiver = mReceivers.get(key); if (receiver == null) { AbsReceiver absReceiver = type.equals(ReceiverType.DOWNLOAD) ? new DownloadReceiver(obj) : new UploadReceiver(obj); mReceivers.put(key, absReceiver); receiver = absReceiver; } return receiver;} 调用download方法，根据obj和ReceiverType.DOWNLOAD类型生成key，查询mReceivers是否已经存在当前对象的下载功能接收器DownloadReceiver，存在直接返回 首次调用，会走到putReceiver方法，新生成一个下载功能接收器DownloadReceiver，并存储在mReceivers中 0x0105 将当前对象注册到Aria 调用DownloadReceiver#register()方法 通过DOWNLOAD注解或者实现DownloadTaskListener接口，调用TaskSchedulers.getInstance().register()将当前类注册到Aria 0x0106 TaskSchedulers注册(TODO)TaskSchedulers 事件调度器，用于处理任务状态的调度 12345678910111213141516171819202122232425262728293031private Map&lt;String, Map&lt;TaskEnum, Object&gt;&gt; mObservers = new ConcurrentHashMap&lt;&gt;();/** * 将当前类注册到Aria * * @param obj 观察者类 * @param taskEnum 任务类型 {@link TaskEnum} */public void register(Object obj, TaskEnum taskEnum) { String targetName = obj.getClass().getName(); Map&lt;TaskEnum, Object&gt; listeners = mObservers.get(getKey(obj)); if (listeners == null) { listeners = new ConcurrentHashMap&lt;&gt;(); mObservers.put(getKey(obj), listeners); } if (!hasProxyListener(listeners, taskEnum)) { if (obj instanceof TaskInternalListenerInterface) { listeners.put(taskEnum, obj); return; } String proxyClassName = targetName + taskEnum.proxySuffix; ISchedulerListener listener = createListener(proxyClassName); if (listener != null) { listener.setListener(obj); listeners.put(taskEnum, listener); } else { ALog.e(TAG, &quot;注册错误，没有【&quot; + proxyClassName + &quot;】观察者&quot;); } }} 0x02 下载流程(TODO)1234long taskId = Aria.download(this) .load(DOWNLOAD_URL) //读取下载地址 .setFilePath(DOWNLOAD_PATH) //设置文件保存的完整路径 .create(); //启动下载 01 DownloadReceiver.load()1 HttpBuilderTarget.create()2 BuilderController.create()3 CmdHelper.createNormalCmd()4 NormalCmdFactory.createCmd() -&gt; StartCmd5 EventMsgUtil.getDefault().post(StartCmd) -&gt; mEventQueue.take()6 EventMsgUtil.sendEvent()7 StartCmd.executeCmd() -&gt; AbsNormalCmd.startTask()8 DTaskQueue.createTask(DTaskWrapper wrapper)9 TaskWrapperManager.getInstance().putTaskWrapper(wrapper)10 AbsTaskQueue.startTask()11 DLoadExecutePool.putTask()12 AbsTask.start()13 HttpDLoaderUtil.start() -&gt; AbsNormalLoaderUtil.start()14 NormalLoader.run() -&gt; AbsNormalLoader.run()15 AbsNormalLoader.startFlow() -&gt; NormalLoader.handleTask()// 启动单线程任务16 NormalLoader.startThreadTask()17 NormalTTBuilder.buildThreadTask()18 ThreadTaskManager.getInstance().startThread()19 AbsNormalLoader.startTimer() // 启动进度获取定时器 21 ThreadTask.call() // 线程池执行任务回调22 AbsThreadTaskAdapter.call()23 HttpDThreadTaskAdapter.handlerThreadTask() // 正式建立Http连接，下载任务24 HttpDThreadTaskAdapter.readNormal() 25 HttpDThreadTaskAdapter.handleComplete()26 ThreadTask.updateCompleteState()27 NormalThreadStateManager.callback -&gt; STATE_COMPLETE28 BaseListener.onComplete() // 对应的实体类是BaseDListener29 BaseListener.sendInState2Target() // 将任务状态发送给下载器 0x03 完成事件逆行分析 IDLoadListener.onComplete() NormalLoader.addComponent(IRecordHandler recordHandler) -&gt; ILoaderVisitor.addComponent(IRecordHandler recordHandler) // 处理任务记录 RecordHandler.checkTaskCompleted() // 检查任务是否已完成 遍历TaskRecord中所有的ThreadRecord.isComplete就认为下载完成 0x04 M3U8文件下载过程M3U8ThreadTaskAdapter.readDynamicFile(InputStream is) // 动态长度文件读取方式M3U8ThreadTaskAdapter.handleComplete() // 处理完成ThreadTask.updateCompleteState() // 组装Message消息，发送给VodStateManager.callback -&gt; Handler.CallbackVodStateManager.callback -&gt; STATE_COMPLETEBaseListener.onComplete() // 对应的实体类是M3U8Listener","link":"/blog/2023/05/25/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Aria%E4%B8%8B%E8%BD%BD%E5%99%A8/"},{"title":"ARouter源码解析","text":"ARouter源码解析0x01 init ()ARouter 的入口，初始化SDK ARouter.init(mApplication);： 1234567891011public static void init(Application application) { if (!hasInit) { // 避免重复初始化 logger = _ARouter.logger; // 日志初始化 _ARouter.logger.info(Consts.TAG, &quot;ARouter init start.&quot;); hasInit = _ARouter.init(application); // 正式初始化 if (hasInit) { // 初始化之后 _ARouter.afterInit(); // 管理拦截器的服务 InterceptorService 初始化 } _ARouter.logger.info(Consts.TAG, &quot;ARouter init over.&quot;); }} _ARouter.init()： 12345678protected static synchronized boolean init(Application application) { mContext = application; // 初始化application LogisticsCenter.init(mContext, executor); // 指定默认的线程池初始化 logger.info(Consts.TAG, &quot;ARouter init success!&quot;); hasInit = true;// 初始化成功 mHandler = new Handler(Looper.getMainLooper());// 初始化mHandler return true;} LogisticsCenter.init() 1 使用 arouter-auto-register 插件自动加载 routerMap 2 手动加载的情况，release 仅第一次会去解析 routerMap，其他时候都读取 SharedPreferences 3 根据routerMap三种类型，分别缓存在Warehouse 的Map中 route and metas provider interceptor 12345678910111213141516171819202122232425262728293031323334353637// LogisticsCenter init, load all metas in memory.public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException { mContext = context; executor = tpe; // 线程池 //... loadRouterMap(); // 插件arouter-auto-register会生成这个方法的代码实现 if (registerByPlugin) { logger.info(TAG, &quot;Load router map by arouter-auto-register plugin.&quot;); } else {// 不用插件手动加载routerMap Set&lt;String&gt; routerMap; // routerMap // Debug 模式每次更新 routerMap，并更新SharedPreferences if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) { routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE); if (!routerMap.isEmpty()) { context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply(); } PackageUtils.updateVersion(context); } else { // 直接从 SharedPreferences 读取 routerMap routerMap = new HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet&lt;String&gt;())); } //... for (String className : routerMap) { if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) { // Load root ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex); } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) { // Load interceptorMeta ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex); } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) { // Load providerIndex ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex); } } } //...} class Warehouse 缓存三种类型的数据 1234567891011121314class Warehouse { // Cache route and metas static Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex = new HashMap&lt;&gt;(); static Map&lt;String, RouteMeta&gt; routes = new HashMap&lt;&gt;(); // Cache provider static Map&lt;Class, IProvider&gt; providers = new HashMap&lt;&gt;(); static Map&lt;String, RouteMeta&gt; providersIndex = new HashMap&lt;&gt;(); // Cache interceptor static Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex = new UniqueKeyTreeMap&lt;&gt;(&quot;More than one interceptors use same priority [%s]&quot;); static List&lt;IInterceptor&gt; interceptors = new ArrayList&lt;&gt;();} 总结来说，init过程就是把所有注解的信息加载内存中，并且完成所有拦截器的初始化。 0x02 navigation()发起路由操作 ARouter.getInstance().build(&quot;/test/activity&quot;).navigation(); 123public Postcard build(String path) { return _ARouter.getInstance().build(path);} 都是单例设计，最后调用 _ARouter 单例的 build() 12345678910111213141516protected Postcard build(String path) { //... PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); if (null != pService) { path = pService.forString(path); } return build(path, extractGroup(path));}protected Postcard build(String path, String group) { //... PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); if (null != pService) { path = pService.forString(path); } return new Postcard(path, group);} PathReplaceService，它是继承IProvider的接口，它是预留给用户实现路径动态变化功能。 Postcard 是一个继承自 RouteMeta 的数据 Bean。 1234567891011121314151617public final class Postcard extends RouteMeta { // Base private Uri uri; private Object tag; // A tag prepare for some thing wrong. private Bundle mBundle; // Data to transform private int flags = -1; // Flags of route private int timeout = 300; // Navigation timeout, TimeUnit.Second private IProvider provider; // It will be set value, if this postcard was provider. private boolean greenChannel; private SerializationService serializationService; // Animation private Bundle optionsCompat; // The transition animation of activity private int enterAnim = -1; private int exitAnim = -1; //...} Postcard 对象的 navigation 方法，最终还是调用的 _Arouter 的 navigation方法。 1 PretreatmentService 进行跳转的拦截和检测 2 LogisticsCenter.completion(postcard) Postcard 加载和自解析 3 Postcard 解析异常 回调 callback.onLost，若 callback 为空则 DegradeService 降级回调处理 4 Postcard 处理结束，回调 callback.onFound(postcard) 5 GreenChannel 的 navigation，直接执行 _navigation 路由 6 非 GreenChannel 的 navigation，异步执行注入拦截器。拦截之后回调 callback.onInterrupt, 通过所有的拦截器，则继续执行 _navigation 路由 123456789101112131415161718192021222324252627282930313233343536373839404142protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) { PretreatmentService pretreatmentService = ARouter.getInstance().navigation(PretreatmentService.class); // ....pretreatmentService拦截 try { LogisticsCenter.completion(postcard);// postcard 自解析 } catch (NoRouteFoundException ex) { // .... if (null != callback) { callback.onLost(postcard); } else { // No callback for this invoke, then we use the global degrade service. DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class); if (null != degradeService) { degradeService.onLost(context, postcard); } } return null; } if (null != callback) { callback.onFound(postcard); // Postcard 处理结束，回调 callback.onFound(postcard) } if (!postcard.isGreenChannel()) { interceptorService.doInterceptions(postcard, new InterceptorCallback() { @Override public void onContinue(Postcard postcard) { _navigation(context, postcard, requestCode, callback); } @Override public void onInterrupt(Throwable exception) { if (null != callback) { callback.onInterrupt(postcard); } } }); } else { return _navigation(context, postcard, requestCode, callback); } return null;} _Arouter 的 _navigation 方法 1 根据 postcard.getType() 处理 2 ACTIVITY 类型， 根据 postcard.getDestination() 生成一个 intent，然后 putExtras， 并设置对应的 flag 和 action 执行跳转 3 PROVIDER 类型，直接返回在 LogisticsCenter.completion(postcard) 生成的 IProvider 实例 4 BOARDCAST，CONTENT_PROVIDER，FRAGMENT 类型分别返回 newInstance() 生成实例，Fragment 会 setArguments 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) { // ... switch (postcard.getType()) { case ACTIVITY: // Build intent final Intent intent = new Intent(currentContext, postcard.getDestination()); intent.putExtras(postcard.getExtras()); // Set flags. int flags = postcard.getFlags(); if (-1 != flags) { intent.setFlags(flags); } else if (!(currentContext instanceof Activity)) { // Non activity, need less one flag. intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); } // Set Actions String action = postcard.getAction(); if (!TextUtils.isEmpty(action)) { intent.setAction(action); } // Navigation in main looper. runInMainThread(new Runnable() { @Override public void run() { startActivity(requestCode, currentContext, intent, postcard, callback); } }); break; case PROVIDER: return postcard.getProvider(); case BOARDCAST: case CONTENT_PROVIDER: case FRAGMENT: Class fragmentMeta = postcard.getDestination(); try { Object instance = fragmentMeta.getConstructor().newInstance(); if (instance instanceof Fragment) { ((Fragment) instance).setArguments(postcard.getExtras()); } else if (instance instanceof android.support.v4.app.Fragment) { ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras()); } return instance; } catch (Exception ex) { // ... } case METHOD: case SERVICE: default: return null; } return null;}","link":"/blog/2020/08/27/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Arouter/"},{"title":"用Android自带浏览器打开网页","text":"启动android默认浏览器12345val intent = Intent()intent.data = Uri.parse(url)intent.action = Intent.ACTION_VIEWintent.flags = Intent.FLAG_ACTIVITY_NEW_TASKcontext.startActivity(intent) 启动指定浏览器打开（不推荐）警告：爱加密加固之后的包，会把这个异常给吃掉，导致无法跳转，也无反应。 这种方式需要处理手机中不存在指定浏览器的情况 1234567891011121314151617181920try { val intent = Intent() intent.data = Uri.parse(targetUrl) intent.action = Intent.ACTION_VIEW intent.setClassName( &quot;com.android.browser&quot;, &quot;com.android.browser.BrowserActivity&quot; ) intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK context.startActivity(intent)} catch (e: Exception) { e.printStackTrace() // android.content.ActivityNotFoundException: Unable to find explicit activity class {com.android.browser/com.android.browser.BrowserActivity}; have you declared this activity in your AndroidManifest.xml? val intent = Intent() intent.data = Uri.parse(url) intent.action = Intent.ACTION_VIEW intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK context.startActivity(intent)} 由于华为鸿蒙系统已经没有Android默认的浏览器，所以此处必须要有异常处理，或者提前处理手机中不存在指定浏览器的情况。 市场上常用浏览器的包名和类名@20220630 123456华为: &quot;com.huawei.browser/com.huawei.browser.BrowserMainActivity&quot;Vivo: &quot;com.vivo.browser/com.vivo.browser.MainActivity&quot;小米: &quot;name=com.android.browser/com.android.browser.BrowserActivity&quot;uc浏览器: &quot;com.uc.browser&quot;, &quot;com.uc.browser.ActivityUpdate&quot;opera: &quot;com.opera.mini.android&quot;, &quot;com.opera.mini.android.Browser&quot;qq浏览器: &quot;com.tencent.mtt&quot;, &quot;com.tencent.mtt.MainActivity&quot;","link":"/blog/2022/06/29/%E7%94%A8Android%E8%87%AA%E5%B8%A6%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5/"},{"title":"Android 13 监控网络连接状态","text":"Android 13 监控网络连接状态获取瞬时状态123456val cm = context.applicationContext.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManagerval currentNetwork = cm.activeNetworkif (currentNetwork != null) { val caps = cm.getNetworkCapabilities(currentNetwork) val linkProperties = cm.getLinkProperties(currentNetwork)} 监听网络事件将 NetworkCallback 类与 ConnectivityManager.registerDefaultNetworkCallback(NetworkCallback) 及 ConnectivityManager.registerNetworkCallback(NetworkCallback) 结合使用。 1234567891011121314151617181920212223val cm = context.applicationContext.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManagercm.registerDefaultNetworkCallback(object : ConnectivityManager.NetworkCallback() { override fun onAvailable(network: Network) { Log.e(TAG, &quot;The default network is now: &quot; + network) } override fun onLost(network: Network) { Log.e(TAG, &quot;The application no longer has a default network. The last default network was &quot; + network) handle(null) } override fun onCapabilitiesChanged( network: Network, networkCapabilities: NetworkCapabilities ) { Log.d(TAG, &quot;The default network changed capabilities: &quot; + networkCapabilities) handle(networkCapabilities) } override fun onLinkPropertiesChanged(network: Network, linkProperties: LinkProperties) { Log.i(TAG, &quot;The default network changed link properties: &quot; + linkProperties) }}) 解析NetworkCapabilities的网络状态信息123456789101112131415161718192021 private fun handle(caps: NetworkCapabilities?) { if (caps != null) { if (caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)) { if ( caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) || caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI_AWARE) ) { setResult(STATE_WIFI) return } else if ( caps.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) || caps.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) ) { setResult(STATE_MOBILE) return } } } setResult(STATE_UNKNOWN) return}","link":"/blog/2023/01/31/%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"},{"title":"简单Socket服务器实现","text":"简单Socket服务器实现服务端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 服务端： * 1）接收客户端的连接 * 2）接收客户端的数据 * 3）把数据反转，并返回给客户端 * 4）重复2，3步骤，直到客户端发送 'bye'，断开连接。 * &lt;p&gt; * 5）新增支持多个客户端 */public class TestServer { public static void main(String[] args) throws IOException { // 1、开启服务器 ServerSocket server = new ServerSocket(8989); ExecutorService executorService = Executors.newCachedThreadPool(); while (true) { // 2、接收一个客户端的连接 Socket socket = server.accept(); Task task = new Task(socket); executorService.execute(task); } }}class Task implements Runnable { Socket socket; public Task(Socket socket) { this.socket = socket; } @Override public void run() { try { // 3、先获取输入流和输出流 InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); // 4、转为字符流 InputStreamReader isr = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(isr); // 处理字符串 String str; PrintStream ps = new PrintStream(outputStream); while ((str = bufferedReader.readLine()) != null) { System.out.println(Thread.currentThread().getName() + &quot;: tick,tick,tick...&quot;); if (&quot;bye&quot;.equals(str)) { ps.println(&quot;see you&quot;); break; } // 反转 StringBuilder sb = new StringBuilder(str); sb.reverse(); // 返回给客户端 ps.println(sb.toString()); } } catch (Exception e) { e.printStackTrace(); } finally { try { // 断开 socket.close(); } catch (IOException e) { e.printStackTrace(); } } }} 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 客户端 * 1）用户输入数据 * 2）发送给服务器 * 3）接收服务器返回的结果 * 4）重复以上步骤，直到输入bye 结束 **/public class TestClient { public static void main(String[] args) throws IOException { // 1. 连接服务器 Socket socket = new Socket(&quot;192.168.124.17&quot;, 8989); /** * 客户端 * 1）用户输入数据 * 2）发送给服务器 * 3）接收服务器返回的结果 * 4）重复以上步骤，直到输入bye 结束 */ Scanner scanner = new Scanner(System.in); PrintStream ps = new PrintStream(socket.getOutputStream()); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); while (true) { //获取用户输入 System.out.println(&quot;Please print something:&quot;); String word = scanner.nextLine(); // 发送给服务端 ps.println(word); // 接收服务器返回的数据 String result = br.readLine(); System.out.println(&quot;Lucy: &quot; + result); if (&quot;see you&quot;.equals(result)) { break; } } // 关闭 scanner.close(); socket.close(); }}","link":"/blog/2020/08/06/%E7%AE%80%E5%8D%95Socket%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"title":"KMP算法(Java版)","text":"KMP算法(Java版)谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。 问题： 有一个文本串S，和一个模式串P，现在要查找P在S中的位置 0x01 暴力算法12345678910111213141516171819// 暴力查找法：不一致的时候直接把i 移动到 i+1 的位置继续比较private static int search(String s, String p) { int sLen = s.length(); int pLen = p.length(); int i = 0, j = 0; while (i &lt; sLen &amp;&amp; j &lt; pLen) { if (s.charAt(i) == p.charAt(j)) { // 字符相同，则继续匹配下一个字符 i++; j++; } else { // i，j 复位 i = i - j + 1; j = 0; } } if (j == pLen) return i - j; return -1;} 0x02 KMP算法123456789101112131415161718192021222324252627282930313233343536// KMP 查找法private static int kmpSearch(String s, String p) { int sLen = s.length(); int pLen = p.length(); int[] next = getNext(p); int i = 0, j = 0; while (i &lt; sLen &amp;&amp; j &lt; pLen) { if (j == -1 || (s.charAt(i) == p.charAt(j))) { i++; j++; } else { j = next[j]; } } if (j == pLen) return i - j; return -1;}// 计算next数组private static int[] getNext(String p) { int len = p.length(); int[] next = new int[len]; next[0] = -1; int j = -1, i = 0; while (i &lt; len - 1) { if (j == -1 || p.charAt(j) == p.charAt(i)) { i++; j++; next[i] = j; } else { j = next[j]; } } // System.out.println(Arrays.toString(next)); return next;}","link":"/blog/2020/08/13/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95Java%E7%89%88/"},{"title":"十大排序算法实现(Java版)","text":"十大排序算法实现(Java版)一. 常用排序算法12345// Java 的进制数表示int a10 = 99;int a2 = 0b101;int a8 = 0143;int a16 = 0x63; 0x01 冒泡排序原理比较相邻的元素。如果第一个比第二个大,就交换他们两个。 对每一对相邻元素做同样的工作,从开始第一对到结尾的最后一对。在这一点,最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤,除了最后一个。 持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较。 代码实现如下： 1234567891011121314151617// 0x01冒泡排序public static int[] bubbleSort(int[] nums) { if (nums != null &amp;&amp; nums.length &gt; 1) { int len = nums.length; int tmp; for (int i = 1; i &lt;= len; i++) { for (int j = 0; j &lt; len - i; j++) { if (nums[j] &gt; nums[j + 1]) { // swap tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; } } } } return nums;} 0x02 选择排序原理第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。 代码实现如下： 1234567891011121314151617// 0x02选择排序public static int[] selectSort(int[] nums) { int len = nums.length; int min, tmp; for (int i = 0; i &lt; len - 1; i++) { min = i; for (int j = i + 1; j &lt; len; j++) { if (nums[j] &lt; nums[min]) min = j; } if (min != i) { // swap tmp = nums[i]; nums[i] = nums[min]; nums[min] = tmp; } } return nums;} 0x03 插入排序原理插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。 时间复杂度在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为 O(N) 。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为O(N^2) 。 空间复杂度插入排序的空间复杂度为常数阶O(1)。 代码实现如下： 12345678910111213141516// 0x03插入排序public static int[] insertSort(int[] nums) { if (nums != null &amp;&amp; nums.length &gt; 1) { int len = nums.length; for (int i = 1; i &lt; len; i++) { int candidate = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; candidate &lt; nums[j]) { nums[j + 1] = nums[j]; j--; } nums[j + 1] = candidate; } } return nums;} 0x04 快速排序原理通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 代码实现如下： 123456789101112131415161718192021222324252627282930313233// 0x04快速排序public static int[] quickSort(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums;}// 0x04快速排序private static void quickSort(int[] nums, int start, int end) { int i = start; int j = end; int key = nums[start]; while (i &lt; j) { while (i &lt; j &amp;&amp; nums[j] &gt; key) { j--;// 右边的数据大，则直接下标左移 } while (i &lt; j &amp;&amp; nums[i] &lt; key) { i++;// 左边的数据更小，则直接下标右移 } if (i &lt; j) { if (nums[i] == nums[j]) { i++;// 两边的数据一样大，直接移动一个下标 } else { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } } // 递归排序左右两边，此时 i == j &amp;&amp; nums[i] == key if (i - 1 &gt; start) quickSort(nums, start, i - 1); if (j + 1 &lt; end) quickSort(nums, j + 1, end);} 0x05 归并排序归并排序（Merge Sort）的工作原理如下：第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾 代码实现如下： 1234567891011121314151617181920212223242526272829303132// 0x05归并排序public static int[] mergeSort(int[] nums) { return mergeSort(nums, 0, nums.length - 1);}// 0x05归并排序private static int[] mergeSort(int[] nums, int l, int r) { if (l == r) return new int[]{nums[l]};// 单个元素的有序数组 int mid = (l + r) / 2; int[] lefts = mergeSort(nums, l, mid); // 左边的有序数组 int[] rights = mergeSort(nums, mid + 1, r);// 右边的有序数组 return merge(lefts, rights); // 合并左右两个有序数组，并返回}// 0x05合并两个有序队列private static int[] merge(int[] nums1, int[] nums2) { int len1 = nums1.length, len2 = nums2.length; int index1 = 0, index2 = 0, index = 0; int[] result = new int[len1 + len2]; for (; index1 &lt; len1 &amp;&amp; index2 &lt; len2; ) { if (nums1[index1] &lt;= nums2[index2]) { result[index++] = nums1[index1++]; } else { result[index++] = nums2[index2++]; } } if (index1 == len1) { System.arraycopy(nums2, index2, result, index, len2 - index2); } if (index2 == len2) { System.arraycopy(nums1, index1, result, index, len1 - index1); } return result;} 0x06 希尔排序希尔排序的实质就是分组插入排序，该方法又称缩小增量排序。原理先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。 代码实现如下： 12345678910111213141516171819// 0x06希尔排序public static int[] shellSort(int[] nums) { if (nums != null &amp;&amp; nums.length &gt; 1) { int len = nums.length; for (int gap = len / 2; gap &gt; 0; gap /= 2) { // gap每次减半 for (int i = 0; i &lt; gap; i++) { //遍历组 for (int m = i; m &lt; len; m += gap) {// 插入排序i int candidate = nums[m]; int n = m - gap; for (; n &gt;= 0 &amp;&amp; nums[n] &gt; candidate; n -= gap) { nums[n + gap] = nums[n]; } nums[n + gap] = candidate; } } } } return nums;}","link":"/blog/2020/08/12/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Java%E7%89%88/"},{"title":"链表(Java版)","text":"链表(Java版)在链表操作中，我们通常通过生成一个 dummy 哑节点，来避免空链表的判断。 19.删除链表的倒数第 N 个结点方法一：计算链表长度 为了方便删除操作，我们可以从哑节点开始遍历 L−n+1 个节点。当遍历到第 L−n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。 方法三：双指针 我们可以使用两个指针 first 和 second 同时对链表进行遍历，并且 first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。 时间复杂度：O(L)，其中 L 是链表的长度。空间复杂度：O(1)。 21.合并两个有序链表 当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里。 当 l1 和 l2 有一个是空的,只需要简单地将非空链表接在合并链表的后面。 23.合并K个升序链表方法一：顺序合并 已经有合并两个有序链表的前提，直接遍历数组，依次合并两个链表得到结果。 方法二：分治合并 将 k 个链表分组并将同一组中的链表合并（递归实现） 进时间复杂度为 O(kn×logk)空间复杂度,递归会使用到 O(logk) 空间代价的栈空间","link":"/blog/2022/10/12/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8Java%E7%89%88/"},{"title":"链表常见问题","text":"链表常见问题12345678910/** * 单链表数据结构 */class Node { int val; Node next; public Node(int val) { this.val = val; }} 0x01 链表翻转题目描述： 这道算法题，说直白点就是：如何让后一个节点指向前一个节点。 1234567891011// 1.翻转链表public static Node reverse(Node head) { Node res = null; while (head != null) { Node h = head.next; head.next = res; res = head; head = h; } return res;} 0x02 两数相加题目描述： Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 123456789101112131415161718// 2.链表相加public static Node plus(Node l1, Node l2) { Node dummyHead = new Node(0); Node l3 = dummyHead; int carry = 0; while (l1 != null || l2 != null || carry &gt; 0) { int val = carry; val = (l1 != null ? val + l1.val : val); val = (l2 != null ? val + l2.val : val); Node t = new Node(val &gt; 9 ? val - 10 : val); l3.next = t; carry = val &gt; 9 ? 1 : 0; l1 = l1 != null ? l1.next : null; l2 = l2 != null ? l2.next : null; l3 = t; } return dummyHead.next;} 0x03 链表中倒数第k个节点题目描述： 输入一个链表，输出该链表中倒数第k个结点。 问题分析： 链表中倒数第k个节点也就是正数第(L-K+1)个节点。 首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第k个节点也就是正数第(L-K+1)个节点。 123456789101112131415161718// 3.链表中倒数第k个节点public static Node findKFromEnd(Node head, int k) { Node node1 = head, node2 = head; int len = 0, index = k; // 链表长度 while (node1 != null) { len++; node1 = node1.next; // 从 len = k -1 的位置开始,执行 K 次， if (index &gt; 0) { index--; } else { node2 = node2.next; } } if (len == 0 || len &lt; k) return null; return node2;} 0x04 删除链表的倒数第N个节点题目描述： 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 问题分析: 两次遍历法 首先我们将添加一个 哑结点(dummyHead)作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n) 个结点那里。我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。 一次遍历法： 链表中倒数第N个节点也就是正数第(L-N+1)个节点。 定义两个节点 node1、node2;node1 节点先跑，node1节点 跑到第 n+1 个节点的时候,node2 节点开始跑.当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点（L代表总链表长度，也就是倒数第 n+1 个节点）。 1234567891011121314151617181920// 4.删除链表的倒数第N个节点public static Node deleteKFromEnd(Node head, int k) { Node dummyHead = new Node(0); dummyHead.next = head; int len = 0, index = k; Node p1 = head, p2 = dummyHead; while (p1 != null) { len++; p1 = p1.next; if (index &gt; 0) { index--; } else { p2 = p2.next; } } if (len &gt;= k &amp;&amp; k &gt; 0) { p2.next = p2.next.next; } return dummyHead.next;} 0x05 合并两个有序的链表题目描述： 输入两个单调递增的链表，输出两个链表合成后的链表，需要合成后的链表单调递增。 1234567891011121314// 5.合并两个排序的链表public static Node merge(Node head1, Node head2) { if (head1 == null) return head2; if (head2 == null) return head1; Node t = null; if (head1.val &lt; head2.val) { t = head1; t.next = merge(head1.next, head2); } else { t = head2; t.next = merge(head1, head2.next); } return t;}","link":"/blog/2020/08/20/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"title":"链表相交","text":"编写一个程序，找到两个单链表相交的起始节点。 例如，下面的两个链表： 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 在节点 c1 开始相交。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 方法一：哈希集合思路和算法 判断两个链表是否相交，可以使用哈希集合存储链表节点。 首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中： 如果当前节点不在哈希集合中，则继续遍历下一个节点； 如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。 如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。 复杂度分析 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。 空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { Set&lt;ListNode&gt; visited = new HashSet&lt;ListNode&gt;(); ListNode temp = headA; while (temp != null) { visited.add(temp); temp = temp.next; } temp = headB; while (temp != null) { if (visited.contains(temp)) { return temp; } temp = temp.next; } return null; }} 方法二：双指针思路和算法 使用双指针的方法，可以将空间复杂度降至 O(1)。 只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。 当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下： 每步操作需要同时更新指针 pA 和 pB； 如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。 如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。 当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。 证明 考虑两种情况，第一种情况是两个链表相交，第二种情况是两个链表不相交。 复杂度分析 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。 空间复杂度：O(1)。 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode pA = headA, pB = headB; while (pA != pB) { pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; }} 参考连接： https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/ https://zhuanlan.zhihu.com/p/48313122","link":"/blog/2021/06/18/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"},{"title":"自定义TextView实现多个文案切换炫酷动画","text":"当显示2个或2个以上文案时，每隔2秒切换气泡文案 核心实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import android.animation.ValueAnimatorimport android.content.Contextimport android.util.AttributeSetimport android.util.Logimport androidx.appcompat.widget.AppCompatTextViewclass TextViewSwitcher @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : AppCompatTextView(context, attrs, defStyleAttr) { private var strs: List&lt;String&gt;? = null private var startPos: Int = 0 private val timeStep = 2000L // 2S private val TAG = &quot;TextViewSwitcher&quot; private val showNext = Runnable { showNextStr() } override fun onAttachedToWindow() { Log.d(TAG, &quot;onAttachedToWindow: &quot;) super.onAttachedToWindow() val size = strs?.size ?: 0 if (size &gt; 1) { handler.postDelayed(showNext, timeStep) } } override fun onDetachedFromWindow() { Log.d(TAG, &quot;onDetachedFromWindow: &quot;) handler.removeCallbacks(showNext) super.onDetachedFromWindow() } fun setTextList(strs: List&lt;String&gt;?, startPos: Int = 0) { Log.d(TAG, &quot;setTextList: &quot;) if (strs.isNullOrEmpty()) return this.strs = strs this.startPos = startPos if (strs.size == 1) { text = strs[0] } else { this.startPos = startPos % strs.size text = strs[this.startPos] } } private fun showNextStr() { var startPos = this.startPos + 1 val size = strs?.size ?: 0 if (size &lt;= 1) return if (startPos &gt;= size) startPos %= size this.startPos = startPos changeTextWithAnimator(this, strs?.get(startPos)) handler.postDelayed(showNext, timeStep) } private fun changeTextWithAnimator( textView: AppCompatTextView?, nextContent: String? ) { if (textView != null) { val animator = ValueAnimator.ofFloat(0f, 2f) animator.duration = 400 var changed = false textView.pivotX = 0f val height = textView.measuredHeight if (height &gt; 0) { textView.pivotY = height.toFloat() } val startWidth = textView.measuredWidth var endWidth = 0 val params = textView.layoutParams animator.addUpdateListener { animation -&gt; val value = animation.animatedValue as Float when { value &lt; 1f -&gt; { textView.rotation = 360 - value * 60 textView.alpha = 1 - value } value &gt; 1f -&gt; { textView.alpha = value - 1 textView.rotation = 360 - (2 - value) * 60 if (!changed) { changed = true textView.text = nextContent val measureSpec = MeasureSpec.makeMeasureSpec( 0, MeasureSpec.UNSPECIFIED ) textView.measure(measureSpec, measureSpec) endWidth = textView.measuredWidth Log.d(TAG, &quot;changeTextWithAnimator: endWidth=$endWidth&quot;) } else { if (endWidth &gt; 0) { params.width = (startWidth + (endWidth - startWidth) * (value - 1)).toInt() textView.layoutParams = params } } } } } animator.start() } }} 由于动画要在顶部浮层，这样动画才能不被父类容器的大小所限制和切割，所以，直接在PopWindow中显示。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.PopupWindowobject HomePromptView { @JvmStatic fun showTipPopView(view: View, typedStr: String?): PopupWindow { val rootView = LayoutInflater.from(view.context).inflate(R.layout.home_prompt_layout, null) val promptTv = rootView.findViewById&lt;TextViewSwitcher&gt;(R.id.tv_prompt) promptTv.setTextList(typedStr?.split(&quot;|&quot;)) rootView.isClickable = false // PopWindow val popTipWid = PopupWindow( rootView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) popTipWid.isTouchable = false // android.view.WindowManager$BadTokenException: // Unable to add window -- token null is not valid; // is your activity running? try { popTipWid.showAtLocation(view.rootView, 0, 0, 0) layoutPromptLocation(promptTv, view)// popTipWid.showAsDropDown(view, UiUtils.dip2px(39), -UiUtils.dip2px(48)) view.addOnLayoutChangeListener { view, i, i2, i3, i4, i5, i6, i7, i8 -&gt; layoutPromptLocation(promptTv, view) } } catch (e: Exception) { e.printStackTrace() } return popTipWid } private fun layoutPromptLocation( promptTv: TextViewSwitcher, view: View ) { try { val params = promptTv.layoutParams as ViewGroup.MarginLayoutParams val location = IntArray(2) view.getLocationInWindow(location) params.topMargin = location[1] - UiUtils.getStatusBarHeight(view.context) + UiUtils.dip2px(4) params.leftMargin = location[0] + UiUtils.dip2px(25) promptTv.layoutParams = params } catch (e: Exception) { e.printStackTrace() } } @JvmStatic fun dismissTipPopView(popTipWid: PopupWindow?) { popTipWid?.dismiss() }} 添加布局代码如下： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/transparent&quot;&gt; &lt;******.TextViewSwitcher android:id=&quot;@+id/tv_prompt&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/common_ui_shape_red_heavy_prompt&quot; android:maxLines=&quot;1&quot; android:paddingStart=&quot;5dp&quot; android:paddingTop=&quot;1.5dp&quot; android:paddingEnd=&quot;5dp&quot; android:paddingBottom=&quot;1.5dp&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;10sp&quot; tools:text=&quot;硬核安利&quot;&gt; &lt;/******.TextViewSwitcher&gt;&lt;/FrameLayout&gt; drawable: 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;corners android:bottomRightRadius=&quot;9dp&quot; android:topLeftRadius=&quot;9dp&quot; android:topRightRadius=&quot;9dp&quot; /&gt; &lt;solid android:color=&quot;#FF5E79&quot; /&gt; &lt;stroke android:width=&quot;0.5dp&quot; android:color=&quot;@color/white&quot; /&gt;&lt;/shape&gt;","link":"/blog/2022/03/09/%E8%87%AA%E5%AE%9A%E4%B9%89TextView%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%88%E5%88%87%E6%8D%A2%E7%82%AB%E9%85%B7%E5%8A%A8%E7%94%BB/"},{"title":"自定义布局：西部世界 第一季","text":"自定义布局：西部世界 第一季这个自定义布局要求显示为 系列名称... + 第一季 ，后面的季内容显示完全，紧贴系列名称显示，系列名称在布局不允许的时候可以部分显示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 系列名称... + 第一季 * 后面的季内容显示完全，紧贴系列名称显示，系列名称在布局不允许的时候可以部分显示 */class FixedEndLinearLayout @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : LinearLayout(context, attrs, defStyleAttr) { override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { //获取父布局测量size和model val widthSize = MeasureSpec.getSize(widthMeasureSpec) val widthMode = MeasureSpec.getMode(widthMeasureSpec) val heightSize = MeasureSpec.getSize(heightMeasureSpec) val heightMode = MeasureSpec.getMode(heightMeasureSpec) if (childCount != 2) throw RuntimeException(&quot;FixedEndLinearLayout must have 2 children.&quot;) val wrapChild = getChildAt(0) val fixedChild = getChildAt(1) //测量 measureChild(fixedChild, widthMeasureSpec, heightMeasureSpec) val fixedParams = fixedChild.layoutParams as MarginLayoutParams val fixedChildWidth = fixedChild.measuredWidth + fixedParams.leftMargin + fixedParams.rightMargin val fixedChildHeight = fixedChild.measuredHeight + fixedParams.topMargin + fixedParams.bottomMargin val wrapChildWidthSpec = ViewGroup.getChildMeasureSpec( widthMeasureSpec, paddingLeft + paddingRight + fixedChildWidth, wrapChild.layoutParams.width ) val wrapChildHeightSpec = ViewGroup.getChildMeasureSpec( heightMeasureSpec, paddingTop + paddingBottom, wrapChild.layoutParams.height ) wrapChild.measure(wrapChildWidthSpec, wrapChildHeightSpec) val wrapParams = wrapChild.layoutParams as MarginLayoutParams val wrapChildWidth = wrapChild.measuredWidth + wrapParams.leftMargin + wrapParams.rightMargin val wrapChildHeight = wrapChild.measuredHeight + wrapParams.topMargin + wrapParams.bottomMargin val width = wrapChildWidth + fixedChildWidth val height = fixedChildHeight.coerceAtLeast(wrapChildHeight) start0 = paddingLeft + wrapParams.leftMargin start1 = paddingLeft + wrapChildWidth + fixedParams.leftMargin setMeasuredDimension( if (widthMode == MeasureSpec.EXACTLY) widthSize else width + paddingLeft + paddingRight, if (heightMode == MeasureSpec.EXACTLY) heightSize else height + paddingTop + paddingBottom ) } private var start0 = 0 private var start1 = 0 override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) { val wrapChild = getChildAt(0) val fixedChild = getChildAt(1) val y0 = (measuredHeight - wrapChild.measuredHeight) / 2 val y1 = (measuredHeight - fixedChild.measuredHeight) / 2 wrapChild.layout( start0, y0, start0 + wrapChild.measuredWidth, y0 + wrapChild.measuredHeight ) fixedChild.layout( start1, y1, start1 + fixedChild.measuredWidth, y1 + fixedChild.measuredHeight ) }}","link":"/blog/2021/06/08/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80-FixedEndLinearLayout/"},{"title":"SpannableString 之居中显示 ImageSpan","text":"自定义布局：SpannableString 之居中显示 ImageSpan 12345678910111213141516171819202122232425class CenteredImageSpan(context: Context, drawableRes: Int) : ImageSpan(context, drawableRes) { override fun draw( canvas: Canvas, text: CharSequence, start: Int, end: Int, x: Float, top: Int, y: Int, bottom: Int, paint: Paint ) { // image to draw val b = drawable // font metrics of text to be replaced val fm = paint.fontMetricsInt var transY = ((y + fm.descent + y + fm.ascent) / 2 - b.bounds.bottom / 2) // to check the last line.(当 image 在单独一行显示时可能会存在这个问题） if (transY &gt; bottom - b.bounds.bottom) transY = bottom - b.bounds.bottom canvas.save() canvas.translate(x, transY.toFloat()) b.draw(canvas) canvas.restore() }} 1234567891011val spanStr = SpannableStringBuilder()spanStr.append(&quot;# &quot;)spanStr.append(title)val imageSpan = CenteredImageSpan(this, R.mipmap.ic_topic_detail_jinghao_black)spanStr.setSpan(imageSpan, 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)// cornerspanStr.append(&quot; #&quot;)val len = spanStr.lengthval cornerSpan = CenteredImageSpan(this, R.mipmap.ic_topic_detail_remen)spanStr.setSpan(cornerSpan, len - 1, len, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)binding.ctTalkDetailInfo.talkNameTv.text = spanStr","link":"/blog/2022/01/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80-SpannableString%E4%B9%8B%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BAImageSpan/"},{"title":"RoundImageView圆角控件","text":"RoundImageView圆角控件示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Path;import android.graphics.RectF;import android.util.AttributeSet;import android.util.Log;import androidx.annotation.Nullable;import androidx.appcompat.widget.AppCompatImageView;public class RoundImageView extends AppCompatImageView { private static final String TAG = &quot;RoundImageView&quot;; private int radius = 0; public RoundImageView(Context context) { this(context, null); } public RoundImageView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public RoundImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); setup(context, attrs, defStyleAttr); } private void setup(Context context, AttributeSet attrs, int defStyleAttr) { try { TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RoundImageView); radius = a.getDimensionPixelSize(R.styleable.RoundImageView_riv_radius, 0); Log.d(TAG, &quot;RoundImageView: radius=&quot; + radius); a.recycle(); } catch (Exception e) { e.printStackTrace(); } } public void setRadius(int radius) { this.radius = radius; } @Override protected void onDraw(Canvas canvas) { if (radius &gt; 0) { Path path = new Path(); path.addRoundRect(new RectF(0, 0, getWidth(), getHeight()), radius, radius, Path.Direction.CW); canvas.clipPath(path);//设置可显示的区域，canvas四个角会被剪裁掉 } super.onDraw(canvas); }} 在 attrs.xml 文件中定义控件的圆角dp值属性: 123&lt;declare-styleable name=&quot;RoundImageView&quot;&gt; &lt;attr name=&quot;riv_radius&quot; format=&quot;dimension&quot; /&gt;&lt;/declare-styleable&gt; 使用示例 123456&lt;com.xx.ui.widget.RoundImageView android:id=&quot;@+id/image_view&quot; android:layout_width=&quot;120dp&quot; android:layout_height=&quot;60dp&quot; android:scaleType=&quot;centerCrop&quot; app:riv_radius=&quot;8dp&quot; /&gt;","link":"/blog/2022/08/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-RoundImageView/"},{"title":"VolumeDialog音量控制自定义","text":"VolumeDialog音量控制自定义1 使用自定义 AlertDialog 实现 2 window?.setFlags 设置 dialog 的样式 3 window?.attributes 设置 dialog 的位置 4 返回键监听，兼容机型需要使用 setOnKeyListener 5 按一次音量键回调多次的问题，KeyEvent.action 事件分 KeyEvent.ACTION_UP 和 KeyEvent.ACTION_DOWN 6 音量加减需要获取系统音量 max 值来手动控制，不同手机 max 值域不同 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import android.app.Activityimport android.content.Contextimport android.content.res.Resourcesimport android.media.AudioManagerimport android.os.Bundleimport android.os.Handlerimport android.os.Looperimport android.util.Logimport android.util.TypedValueimport android.view.Gravityimport android.view.KeyEventimport android.view.WindowManagerimport android.widget.ProgressBarimport androidx.appcompat.app.AlertDialog/** * 声音调整控件 */class VolumeDialog(activity: Activity) : AlertDialog(activity, R.style.VolumeDialog) { companion object { private const val TAG = &quot;VolumeDialog&quot; @JvmStatic fun show(activity: Activity) { activity.let { if (activity.isFinishing) return VolumeDialog(activity).show() } } } private val volumeAudioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager private var volume = volumeAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC) private val maxVolume = volumeAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC) private val step = (maxVolume / 10).coerceAtLeast(1) private val delayMillis = 1500L override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.dialog_volume_progress) //实现Dialog区域外部事件可以传给Activity // FLAG_NOT_TOUCH_MODAL作用：即使该window可获得焦点情况下，仍把该window之外的任何event发送到该window之后的其他window window?.setFlags( WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL, WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL ) // FLAG_WATCH_OUTSIDE_TOUCH作用：如果点击事件发生在window之外，就会收到一个特殊的MotionEvent，为ACTION_OUTSIDE window?.setFlags( WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH, WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH ) // 顶部显示 // window?.setGravity(Gravity.TOP) val attrs = window?.attributes attrs?.apply { gravity = Gravity.TOP height = WindowManager.LayoutParams.WRAP_CONTENT width = WindowManager.LayoutParams.MATCH_PARENT y = TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, 35f, Resources.getSystem().displayMetrics ).toInt() } Log.d(TAG, &quot;onCreate() called with: attrs = $attrs&quot;) window?.attributes = attrs // 按空白处不能取消 setCanceledOnTouchOutside(false) // 初始化界面控件 initView() } private var volumeProgressView: VolumeProgressView? = null private var progressBar: ProgressBar? = null private val _handler = Handler(Looper.getMainLooper()) private val r = Runnable { try { dismiss() } catch (e: Exception) { // sometimes happens windows token error. e.printStackTrace() } } override fun dismiss() { _handler.removeCallbacks(r) super.dismiss() } private fun initView() { Log.d(TAG, &quot;initView: &quot;) volumeProgressView = findViewById(R.id.vpv_volume) progressBar = findViewById(R.id.pb_volume) refreshProgress(volume * 1f / maxVolume) // 解决不同机型版本兼容问题，onKeyDown 可能被拦截 setOnKeyListener { _, keyCode, event -&gt; Log.d(TAG, &quot;setOnKeyListener: keyCode = $keyCode, event = $event&quot;) if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) { handleKeyEvent(keyCode, event) true } else { false } } } private fun refreshProgress(volumePercent: Float) { _handler.removeCallbacks(r) volumeProgressView?.setProgress(volumePercent) progressBar?.progress = (volumePercent * 1000).toInt() _handler.postDelayed(r, delayMillis) } private fun handleKeyEvent(keyCode: Int, event: KeyEvent): Boolean { Log.d(TAG, &quot;handleKeyEvent: volume = $volume, maxVolume = $maxVolume, step = $step&quot;) if ((keyCode != KeyEvent.KEYCODE_VOLUME_UP &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_DOWN) || event.action != KeyEvent.ACTION_DOWN) return false volume = if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) { // up if (volume == maxVolume) return true maxVolume.coerceAtMost(volume + step) } else { // down if (volume == 0) return true 0.coerceAtLeast(volume - step) } val volumePercent = volume * 1f / maxVolume refreshProgress(volumePercent) // 变更声音 volumeAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, volume, 0) Log.d(TAG, &quot;handleKeyEvent: AudioManager set volume = $volume done.&quot;) return true } /** * 返回事件，仅拦截音量控制事件 */ override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean { Log.d(TAG, &quot;onKeyDown() called with: keyCode = $keyCode, event = $event&quot;) return if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) { handleKeyEvent(keyCode, event) return true } else { super.onKeyDown(keyCode, event) } }} 自定义Dialog的Style 123456789101112 &lt;style name=&quot;VolumeDialog&quot; parent=&quot;android:style/Theme.Dialog&quot;&gt; &lt;!--背景颜色及和透明程度--&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;!--是否去除标题 --&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;!--是否去除边框--&gt; &lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt; &lt;!--是否浮现在activity之上--&gt; &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt; &lt;!--是否模糊--&gt; &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt;&lt;/style&gt;","link":"/blog/2021/05/24/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-VolumeDialog/"},{"title":"设计模式@Java","text":"设计模式 Java版设计模式（Design Pattern）的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点： 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 根据目的用途来划分，可分为创建型模式、结构型模式和行为型模式 3 种。 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 根据作用范围来分，可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 0x01 单例模式单例模式是运用最广泛的设计模式之一，应用单例模式的类在整个程序中只有一个实例存在。通常用于很消耗资源的类，比如线程池，缓存，网络请求，IO操作，访问数据库等。为保证单例模式的线程安全，采用 双重校验。示例代码： 12345678910public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance;} 0x02 Builder模式将一个复杂对象的构建与对象的参数或部件的创建分离，达到解耦的目的。用户不用知道内部构建细节，可以更好的控制构建流程。 1234567891011121314151617181920public class Person { private int ID; private Person(Builder builder) { this.ID = builder.ID; } public static class Builder { private int ID; public Builder setID(int ID) { this.ID = ID; return this; } public Person build() { return new Person(this); } }}Person.Builder buider = new Person.Builder();buider.setID(1001);Person p1 = buider.build(); 0x03 工厂模式工厂模式是创建型模式，多用于需要生成复杂对象的地方。用new就可以完成创建的对象就无需使用。工厂模式降低了对象之间的耦合度，由于工厂模式依赖抽象的架构，实例化的任务交由子类去完成，所以有很好的扩展性。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 工厂设计模式 * &lt;p&gt; * 为了解耦合，由工厂统一创建对象实例。 */interface Vehicle { void trip();}class QQ implements Vehicle { @Override public void trip() { System.out.println(&quot;QQ飞车...&quot;); }}class BenZ implements Vehicle { @Override public void trip() { System.out.println(&quot;奔驰跑车...&quot;); }}class VehicleFactory { public static final int QQ = 0x0001; public static final int BEN_Z = 0x0002; public static final Vehicle buildVehicle(int type) { if (QQ == type) { return new QQ(); } else if (BEN_Z == type) { return new BenZ(); } return null; }}public class FactoryTest { public static void main(String[] args) { Vehicle vehicle = VehicleFactory.buildVehicle(VehicleFactory.QQ); vehicle.trip(); }} 0x04 观察者模式让观察者和被观察者逻辑分开。使得UI层和业务逻辑清晰。 定义一个观察者： 12345678910111213public class PersonObserver implements Observer { static final String TAG = PersonObserver.class.getSimpleName(); String name; public PersonObserver (String name) { this.name = name; } @Override public void update(Observable observable, Object o) { Log.d(TAG,name + &quot; 接收到通知啦 &quot;+ o); }} 定义一个被观察者 12345678910111213141516171819public class PersonObservable extends Observable { List&lt;PersonObserver&gt; list = new ArrayList&lt;&gt;(); public void addObserver(PersonObserver observer) { list.add(observer); } public void removeObserver(PersonObserver observer) { if (list.contains(observer)){ list.remove(observer); } } public void notify(String info) { for (PersonObserver observer : list) { observer.update(this, info); };// 通知所有观察者 }} 注册和通知 123456PersonObserver xiaoMing = new PersonObserver(&quot;xiaoMing&quot;);// 注册PersonObservable pObservable = new PersonObservable();pObservable.addObserver(xiaoMing);// 通知pObservable.notify(&quot;notify!&quot;); 0x05 代理模式（Proxy）代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。代理类和委托类（被代理类）应该共同实现一个接口，或者是共同继承某个类。 1）静态代理 12345678910111213141516171819202122232425262728293031323334353637383940/** * 1）静态代理 */interface DAO { void build();}class PartnerDAO implements DAO { @Override public void build() { System.out.println(&quot;PartnerDAO...&quot;); }}class DAOProxy implements DAO { private DAO dao; public DAOProxy(DAO dao) { this.dao = dao; } @Override public void build() { System.out.println(&quot;build start...&quot;); long start = System.currentTimeMillis(); dao.build(); long end = System.currentTimeMillis(); System.out.println(&quot;build start...&quot;); System.out.println(&quot;执行耗费时间：&quot; + (end - start)); }}public class ProxyTest { @Test public void test1() { PartnerDAO dao = new PartnerDAO(); DAOProxy daoProxy = new DAOProxy(dao); daoProxy.build(); }} 2）动态代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 2）动态代理 */interface DAO { void build();}class PartnerDAO implements DAO { @Override public void build() { System.out.println(&quot;PartnerDAO build().&quot;); }}interface B { int work(boolean free);}class PartnerB implements B { // 不需要继承同一个接口或类 @Override public int work(boolean free) { System.out.println(&quot;PartnerB work().&quot;); return 2; }}class DAOHandler implements InvocationHandler { private Object target; public DAOHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName() + &quot; start...&quot;); long start = System.currentTimeMillis(); Object result = method.invoke(target, args);// 执行原来的任务 long end = System.currentTimeMillis(); System.out.println(method.getName() + &quot; start...&quot;); System.out.println(&quot;执行耗费时间：&quot; + (end - start)); return result; // 返回执行结果 }}public class ProxyTest { @Test public void test1() { PartnerDAO dao = new PartnerDAO(); ClassLoader loader = dao.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = dao.getClass().getInterfaces(); DAOHandler h = new DAOHandler(dao); DAO a1 = (DAO) Proxy.newProxyInstance(loader, interfaces, h); a1.build(); } @Test public void test2() { PartnerB pb = new PartnerB(); ClassLoader loader = pb.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = pb.getClass().getInterfaces(); DAOHandler h = new DAOHandler(pb); B b = (B) Proxy.newProxyInstance(loader, interfaces, h); b.work(true); }} 静态代理和动态代理的区别，静态代理一个代理类针对一个委托类，动态代理一个代理类可利用反射机制代理多个委托类。 静态代理在代码编译时就确定了委托类的类型，动态代理在代码运行时才动态加载委托类，运行时才确定委托类的类型。 使用场景：比如RPC框架和Spring AOP机制。 0x06 迭代器模式根据传入的列表类数据提供一个额外的遍历方法。 1234// 迭代器提供遍历方法，遍历while (cursor.hasNext()) { Log.d(&quot;Cursor&quot;,cursor.next());} 0x07 适配器模式( ListView 与 Adapter )将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作","link":"/blog/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F@Java/"},{"title":"阿里云 Maven 仓库","text":"0x01 阿里云Maven仓库仓库地址:https://maven.aliyun.com/mvn/view 12maven { url 'https://maven.aliyun.com/repository/public' }maven { url 'https://maven.aliyun.com/repository/google' } 0x02 Gradle配置指南在 build.gradle 文件中加入以下代码: 123456789allprojects { repositories { maven { url 'https://maven.aliyun.com/repository/public/' // public仓是包含central仓和jcenter仓的聚合仓 } mavenLocal() mavenCentral() }} 如果想使用其它代理仓，以使用spring仓为例，代码如下: 123456789101112allProjects { repositories { maven { url 'https://maven.aliyun.com/repository/public/' } maven { url 'https://maven.aliyun.com/repository/spring/' } mavenLocal() mavenCentral() }} 加入你要引用的文件信息： 123dependencies { compile '[GROUP_ID]:[ARTIFACT_ID]:[VERSION]'} 执行命令： 1gradle dependencies 或 ./gradlew dependencies 安装依赖","link":"/blog/2020/02/26/%E9%98%BF%E9%87%8C%E4%BA%91Maven%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/"},{"title":"为什么选择Netty","text":"为什么选择NettyNetty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro就使用了Netty作为底层通信框架，其他如Strom还有业界主流的RPC框架，也使用Netty来构建高性能的异步通信能力。 通过对Netty的分析，我们将它的优点总结如下。 ◎ API使用简单，开发门槛低； ◎ 功能强大，预置了多种编解码功能，支持多种主流协议； ◎ 定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展； ◎ 性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优； ◎ 成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼； ◎ 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入； ◎ 经历了大规模的商业应用考验，质量得到验证。Netty在互联网、大数据、网络游戏、企业应用、电信软件等众多行业已经得到了成功商用，证明它已经完全能够满足不同行业的商业应用了。 正是因为这些优点，Netty逐渐成为了Java NIO编程的首选框架。 Netty 是什么？那Netty到底是什么？官方解释：Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。Netty就是一个对Jdk的Nio进行封装的一个框架。 Netty is an asynchronous event-driven network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients. https://netty.io/ 在开始了解 Netty 是什么之前，我们先来回顾一下，如果我们需要实现一个客户端与服务端通信的程序，使用传统的 IO 编程，应该如何来实现？ IO编程我们简化下场景：客户端每隔两秒发送一个带有时间戳的 “hello world” 给服务端，服务端收到之后打印。 为了方便演示，下面例子中，服务端和客户端各一个类，把这两个类拷贝到你的 IDE 中，先后运行 IOServer.java 和IOClient.java可看到效果。 下面是传统的 IO 编程中服务端实现 IOServer.java 123456789101112131415161718192021222324252627282930313233343536/** * @author 闪电侠 */public class IOServer { public static void main(String[] args) throws Exception { ServerSocket serverSocket = new ServerSocket(8000); // (1) 接收新连接线程 new Thread(() -&gt; { while (true) { try { // (1) 阻塞方法获取新的连接 Socket socket = serverSocket.accept(); // (2) 每一个新的连接都创建一个线程，负责读取数据 new Thread(() -&gt; { try { int len; byte[] data = new byte[1024]; InputStream inputStream = socket.getInputStream(); // (3) 按字节流方式读取数据 while ((len = inputStream.read(data)) != -1) { System.out.println(new String(data, 0, len)); } } catch (IOException e) { } }).start(); } catch (IOException e) { } } }).start(); }} Server 端首先创建了一个serverSocket来监听 8000 端口，然后创建一个线程，线程里面不断调用阻塞方法 serversocket.accept();获取新的连接，见(1)，当获取到新的连接之后，给每条连接创建一个新的线程，这个线程负责从该连接中读取数据，见(2)，然后读取数据是以字节流的方式，见(3)。 下面是传统的IO编程中客户端实现 IOClient.java 123456789101112131415161718192021/** * @author 闪电侠 */public class IOClient { public static void main(String[] args) { new Thread(() -&gt; { try { Socket socket = new Socket(&quot;127.0.0.1&quot;, 8000); while (true) { try { socket.getOutputStream().write((new Date() + &quot;: hello world&quot;).getBytes()); Thread.sleep(2000); } catch (Exception e) { } } } catch (IOException e) { } }).start(); }} 客户端的代码相对简单，连接上服务端 8000 端口之后，每隔 2 秒，我们向服务端写一个带有时间戳的 “hello world”。 IO 编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服务端可能需要支撑成千上万的连接，IO 模型可能就不太合适了，我们来分析一下原因。 上面的 demo，从服务端代码中我们可以看到，在传统的 IO 模型中，每个连接创建成功之后都需要一个线程来维护，每个线程包含一个 while 死循环，那么 1w 个连接对应 1w 个线程，继而 1w 个 while 死循环，这就带来如下几个问题： 线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起 线程切换效率低下：单机 CPU 核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。 除了以上两个问题，IO 编程中，我们看到数据读写是以字节流为单位。 为了解决这三个问题，JDK 在 1.4 之后提出了 NIO。 NIO 编程关于 NIO 相关的文章网上也有很多，这里不打算详细深入分析，下面简单描述一下 NIO 是如何解决以上三个问题的。 线程资源受限NIO 编程模型中，新来一个连接不再创建一个新的线程，而是可以把这条连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责，那么他是怎么做到的？我们用一幅图来对比一下 IO 与 NIO 如上图所示，IO 模型中，一个连接来了，会创建一个线程，对应一个 while 死循环，死循环的目的就是不断监测这条连接上是否有数据可以读，大多数情况下，1w 个连接里面同一时刻只有少量的连接有数据可读，因此，很多个 while 死循环都白白浪费掉了，因为读不出啥数据。 而在 NIO 模型中，他把这么多 while 死循环变成一个死循环，这个死循环由一个线程控制，那么他又是如何做到一个线程，一个 while 死循环就能监测1w个连接是否有数据可读的呢？ 这就是 NIO 模型中 selector 的作用，一条连接来了之后，现在不创建一个 while 死循环去监听是否有数据可读了，而是直接把这条连接注册到 selector 上，然后，通过检查这个 selector，就可以批量监测出有数据可读的连接，进而读取数据，下面我再举个非常简单的生活中的例子说明 IO 与 NIO 的区别。 在一家幼儿园里，小朋友有上厕所的需求，小朋友都太小以至于你要问他要不要上厕所，他才会告诉你。幼儿园一共有 100 个小朋友，有两种方案可以解决小朋友上厕所的问题： 每个小朋友配一个老师。每个老师隔段时间询问小朋友是否要上厕所，如果要上，就领他去厕所，100 个小朋友就需要 100 个老师来询问，并且每个小朋友上厕所的时候都需要一个老师领着他去上，这就是IO模型，一个连接对应一个线程。 所有的小朋友都配同一个老师。这个老师隔段时间询问所有的小朋友是否有人要上厕所，然后每一时刻把所有要上厕所的小朋友批量领到厕所，这就是 NIO 模型，所有小朋友都注册到同一个老师，对应的就是所有的连接都注册到一个线程，然后批量轮询。 这就是 NIO 模型解决线程资源受限的方案，实际开发过程中，我们会开多个线程，每个线程都管理着一批连接，相对于 IO 模型中一个线程管理一条连接，消耗的线程资源大幅减少 线程切换效率低下由于 NIO 模型中线程数量大大降低，线程切换效率因此也大幅度提高 IO读写面向流IO 读写是面向流的，一次性只能从流中读取一个或者多个字节，并且读完之后流无法再读取，你需要自己缓存数据。 而 NIO 的读写是面向 Buffer 的，你可以随意读取里面任何一个字节数据，不需要你自己缓存数据，这一切只需要移动读写指针即可。 简单讲完了 JDK NIO 的解决方案之后，我们接下来使用 NIO 的方案替换掉 IO 的方案，我们先来看看，如果用 JDK 原生的 NIO 来实现服务端，该怎么做 前方高能预警：以下代码可能会让你感觉极度不适，如有不适，请跳过 NIOServer.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @author 闪电侠 */public class NIOServer { public static void main(String[] args) throws IOException { Selector serverSelector = Selector.open(); Selector clientSelector = Selector.open(); new Thread(() -&gt; { try { // 对应IO编程中服务端启动 ServerSocketChannel listenerChannel = ServerSocketChannel.open(); listenerChannel.socket().bind(new InetSocketAddress(8000)); listenerChannel.configureBlocking(false); listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT); while (true) { // 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms if (serverSelector.select(1) &gt; 0) { Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = set.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isAcceptable()) { try { // (1) 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept(); clientChannel.configureBlocking(false); clientChannel.register(clientSelector, SelectionKey.OP_READ); } finally { keyIterator.remove(); } } } } } } catch (IOException ignored) { } }).start(); new Thread(() -&gt; { try { while (true) { // (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms if (clientSelector.select(1) &gt; 0) { Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = set.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isReadable()) { try { SocketChannel clientChannel = (SocketChannel) key.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // (3) 面向 Buffer clientChannel.read(byteBuffer); byteBuffer.flip(); System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer) .toString()); } finally { keyIterator.remove(); key.interestOps(SelectionKey.OP_READ); } } } } } } catch (IOException ignored) { } }).start(); }} 相信大部分没有接触过 NIO 的同学应该会直接跳过代码来到这一行：原来使用 JDK 原生 NIO 的 API 实现一个简单的服务端通信程序是如此复杂! 复杂得我都没耐心解释这一坨代码的执行逻辑(开个玩笑)，我们还是先对照 NIO 来解释一下几个核心思路 NIO 模型中通常会有两个线程，每个线程绑定一个轮询器 selector ，在我们这个例子中serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读 服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 1w 个 while 循环在死等，参见(1) clientSelector被一个 while 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过 clientSelector.select(1)方法可以轮询出来，进而批量处理，参见(2) 数据的读写面向 Buffer，参见(3) 其他的细节部分，我不愿意多讲，因为实在是太复杂，你也不用对代码的细节深究到底。总之，强烈不建议直接基于JDK原生NIO来进行网络开发，下面是我总结的原因 JDK 的 NIO 编程需要了解很多的概念，编程复杂，对 NIO 入门非常不友好，编程模型不友好，ByteBuffer 的 Api 简直反人类 对 NIO 编程来说，一个比较合适的线程模型能充分发挥它的优势，而 JDK 没有给你实现，你需要自己实现，就连简单的自定义协议拆包都要你自己实现 JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100% 项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高，上面这一坨代码我都不能保证没有 bug 正因为如此，我客户端代码都懒得写给你看了==!，你可以直接使用IOClient.java与NIOServer.java通信 JDK 的 NIO 犹如带刺的玫瑰，虽然美好，让人向往，但是使用不当会让你抓耳挠腮，痛不欲生，正因为如此，Netty 横空出世！ Netty编程那么 Netty 到底是何方神圣？ 用一句简单的话来说就是：Netty 封装了 JDK 的 NIO，让你用得更爽，你不用再写一大堆复杂的代码了。 用官方正式的话来说就是：Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。 下面是我总结的使用 Netty 不使用 JDK 原生 NIO 的原因 使用 JDK 自带的NIO需要了解太多的概念，编程复杂，一不小心 bug 横飞 Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从 NIO 模型变身为 IO 模型 Netty 自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑 Netty 解决了 JDK 的很多包括空轮询在内的 Bug Netty 底层对线程，selector 做了很多细小的优化，精心设计的 reactor 线程模型做到非常高效的并发处理 自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手 Netty 社区活跃，遇到问题随时邮件列表或者 issue Netty 已经历各大 RPC 框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大 看不懂没有关系，这些我们在后续的课程中我们都可以学到，接下来我们用 Netty 的版本来重新实现一下本文开篇的功能吧 首先，引入 Maven 依赖，本文后续 Netty 都是基于 4.1.6.Final 版本 12345&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.6.Final&lt;/version&gt;&lt;/dependency&gt; 然后，下面是服务端实现部分 NettyServer.java 1234567891011121314151617181920212223242526/** * @author 闪电侠 */public class NettyServer { public static void main(String[] args) { ServerBootstrap serverBootstrap = new ServerBootstrap(); NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup worker = new NioEventLoopGroup(); serverBootstrap .group(boss, worker) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() { protected void initChannel(NioSocketChannel ch) { ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() { @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) { System.out.println(msg); } }); } }) .bind(8000); }} 这么一小段代码就实现了我们前面 NIO 编程中的所有的功能，包括服务端启动，接受新连接，打印客户端传来的数据，怎么样，是不是比 JDK 原生的 NIO 编程优雅许多？ 初学 Netty 的时候，由于大部分人对 NIO 编程缺乏经验，因此，将 Netty 里面的概念与 IO 模型结合起来可能更好理解 boss 对应 IOServer.java 中的接受新连接线程，主要负责创建新连接 worker 对应 IOServer.java 中的负责读取数据的线程，主要用于读取数据以及业务逻辑处理 然后剩下的逻辑我在后面的系列文章中会详细分析，你可以先把这段代码拷贝到你的 IDE 里面，然后运行 main 函数 然后下面是客户端 NIO 的实现部分 NettyClient.java 12345678910111213141516171819202122232425/** * @author 闪电侠 */public class NettyClient { public static void main(String[] args) throws InterruptedException { Bootstrap bootstrap = new Bootstrap(); NioEventLoopGroup group = new NioEventLoopGroup(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;Channel&gt;() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }); Channel channel = bootstrap.connect(&quot;127.0.0.1&quot;, 8000).channel(); while (true) { channel.writeAndFlush(new Date() + &quot;: hello world!&quot;); Thread.sleep(2000); } }} 在客户端程序中，group对应了我们IOClient.java中 main 函数起的线程，剩下的逻辑我在后面的文章中会详细分析，现在你要做的事情就是把这段代码拷贝到你的 IDE 里面，然后运行 main 函数，最后回到 NettyServer.java 的控制台，你会看到效果。 使用 Netty 之后是不是觉得整个世界都美好了，一方面 Netty 对 NIO 封装得如此完美，写出来的代码非常优雅，另外一方面，使用 Netty 之后，网络通信这块的性能问题几乎不用操心，尽情地让 Netty 榨干你的 CPU 吧。 资料：1、选择Netty作为基础通信框架 :https://www.cnblogs.com/mxyhws/p/5500425.html 2、Nginx/Netty/ZeroMQ网络模型: https://blog.csdn.net/kobejayandy/article/details/20294909","link":"/blog/2020/12/29/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Netty/"},{"title":"SpannableString 之显示查看全文","text":"SpannableString 之显示查看全文显示内容超出规定的行数之后，显示 展开 和 收起 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629import android.content.Context;import android.graphics.Color;import android.os.Build;import android.text.Layout;import android.text.SpannableString;import android.text.SpannableStringBuilder;import android.text.Spanned;import android.text.StaticLayout;import android.text.TextPaint;import android.text.TextUtils;import android.text.style.AlignmentSpan;import android.text.style.ClickableSpan;import android.text.style.StyleSpan;import android.util.AttributeSet;import android.view.View;import android.view.animation.Animation;import android.view.animation.Transformation;import androidx.annotation.ColorInt;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.appcompat.widget.AppCompatTextView;import java.lang.reflect.Field;/** * Description : 显示展开和收起 * PackageName : com.mrtrying.widget * Created by mrtrying on 2019/4/17 17:21. * e_mail : ztanzeyu@gmail.com */public class ExpandableTextView extends AppCompatTextView { private static final String TAG = ExpandableTextView.class.getSimpleName(); public static final String ELLIPSIS_STRING = new String(new char[]{'\\u2026'}); private static final String DEFAULT_OPEN_SUFFIX = &quot; 展开&quot;; private static final String DEFAULT_CLOSE_SUFFIX = &quot; 收起&quot;; volatile boolean animating = false; boolean isClosed = false; private int mMaxLines = getMaxLines(); private int initWidth = 0; private CharSequence originalText; private SpannableStringBuilder mOpenSpannableStr, mCloseSpannableStr; private boolean hasAnimation = false; private Animation mOpenAnim, mCloseAnim; private int mOpenHeight, mCLoseHeight; private boolean mExpandable; private boolean mCloseInNewLine; @Nullable private SpannableString mOpenSuffixSpan, mCloseSuffixSpan; private String mOpenSuffixStr = DEFAULT_OPEN_SUFFIX; private String mCloseSuffixStr = &quot;&quot;; private int mOpenSuffixColor, mCloseSuffixColor; private int mNormalColor = Color.parseColor(&quot;#FF222222&quot;); private View.OnClickListener mOnClickListener; private CharSequenceToSpannableHandler mCharSequenceToSpannableHandler; private IOnOpenSuffixSpanListener onOpenSuffixSpanListener; public ExpandableTextView(Context context) { super(context); initialize(); } public ExpandableTextView(Context context, AttributeSet attrs) { super(context, attrs); initialize(); } public ExpandableTextView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initialize(); } /** * 初始化 */ private void initialize() { mOpenSuffixColor = mCloseSuffixColor = Color.parseColor(&quot;#FF0091FF&quot;); setMovementMethod(CustomLinkMovementMethod.getInstance());// setIncludeFontPadding(false); updateOpenSuffixSpan(); updateCloseSuffixSpan(); } @Override public boolean hasOverlappingRendering() { return false; } public void setOriginalText(CharSequence originalText) { this.originalText = originalText; mExpandable = false; mCloseSpannableStr = new SpannableStringBuilder(); final int maxLines = mMaxLines; SpannableStringBuilder tempText = charSequenceToSpannable(originalText); mOpenSpannableStr = charSequenceToSpannable(originalText); if (maxLines != -1) { Layout layout = createStaticLayout(tempText); mExpandable = layout.getLineCount() &gt; maxLines; if (mExpandable) { //拼接展开内容 if (mCloseInNewLine) { mOpenSpannableStr.append(&quot;\\n&quot;); } if (mCloseSuffixSpan != null) { mOpenSpannableStr.append(mCloseSuffixSpan); } //计算原文截取位置 int endPos = layout.getLineEnd(maxLines - 1); if (originalText.length() &lt;= endPos) { mCloseSpannableStr = charSequenceToSpannable(originalText); } else { mCloseSpannableStr = charSequenceToSpannable(originalText.subSequence(0, endPos)); } SpannableStringBuilder tempText2 = charSequenceToSpannable(mCloseSpannableStr).append(ELLIPSIS_STRING); if (mOpenSuffixSpan != null) { tempText2.append(mOpenSuffixSpan); } //循环判断，收起内容添加展开后缀后的内容 Layout tempLayout = createStaticLayout(tempText2); while (tempLayout.getLineCount() &gt; maxLines) { int lastSpace = mCloseSpannableStr.length() - 1; if (lastSpace == -1) { break; } if (originalText.length() &lt;= lastSpace) { mCloseSpannableStr = charSequenceToSpannable(originalText); } else { mCloseSpannableStr = charSequenceToSpannable(originalText.subSequence(0, lastSpace)); } tempText2 = charSequenceToSpannable(mCloseSpannableStr).append(ELLIPSIS_STRING); if (mOpenSuffixSpan != null) { tempText2.append(mOpenSuffixSpan); } tempLayout = createStaticLayout(tempText2); } int lastSpace = mCloseSpannableStr.length();// - mOpenSuffixSpan.length();// if(lastSpace &gt;= 0 &amp;&amp; originalText.length() &gt; lastSpace){// CharSequence redundantChar = originalText.subSequence(lastSpace, lastSpace + mOpenSuffixSpan.length());// int offset = hasEnCharCount(redundantChar) - hasEnCharCount(mOpenSuffixSpan) + 1;// lastSpace = offset &lt;= 0 ? lastSpace : lastSpace - offset;// mCloseSpannableStr = charSequenceToSpannable(originalText.subSequence(0, lastSpace));// } //计算收起的文本高度 mCLoseHeight = tempLayout.getHeight() + getPaddingTop() + getPaddingBottom();// mCloseSpannableStr.setSpan(new ClickableSpan() {// @Override// public void onClick(@NonNull View widget) {// if (mOnClickListener != null) {// mOnClickListener.onClick(widget);// }// }//// @Override// public void updateDrawState(@NonNull TextPaint ds) {// super.updateDrawState(ds);// ds.setColor(mNormalColor);// ds.setUnderlineText(false);// }// }, 0, length, Spanned.SPAN_INCLUSIVE_INCLUSIVE); } } isClosed = mExpandable; if (mExpandable) {// mCloseSpannableStr.setSpan(new ClickableSpan() {// @Override// public void onClick(@NonNull View widget) {// if(listener!=null){// listener.onClick(widget);// }// }//// @Override// public void updateDrawState(@NonNull TextPaint ds) {// super.updateDrawState(ds);// ds.setColor(mNormalColor);// ds.setUnderlineText(false);// }// }, 0, mCloseSpannableStr.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE); mCloseSpannableStr.append(ELLIPSIS_STRING); if (mOpenSuffixSpan != null) { mCloseSpannableStr.append(mOpenSuffixSpan); } setMovementMethod(CustomLinkMovementMethod.getInstance()); setClickable(false); setLongClickable(false); setText(mCloseSpannableStr); } else {// mOpenSpannableStr.setSpan(new ClickableSpan() {// @Override// public void onClick(@NonNull View widget) {// if (mOnClickListener != null) {// mOnClickListener.onClick(widget);// }// }//// @Override// public void updateDrawState(@NonNull TextPaint ds) {// super.updateDrawState(ds);// ds.setColor(mNormalColor);// ds.setUnderlineText(false);// }// }, 0, mOpenSpannableStr.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE); setText(mOpenSpannableStr); } } private int hasEnCharCount(CharSequence str) { int count = 0; if (!TextUtils.isEmpty(str)) { for (int i = 0; i &lt; str.length(); i++) { char c = str.charAt(i); if (c &gt;= ' ' &amp;&amp; c &lt;= '~') { count++; } } } return count; } private void switchOpenClose() { if (mExpandable) { isClosed = !isClosed; if (isClosed) { close(); } else { open(); } } } /** * 设置是否有动画 * * @param hasAnimation */ public void setHasAnimation(boolean hasAnimation) { this.hasAnimation = hasAnimation; } /** * 展开 */ private void open() { if (hasAnimation) { Layout layout = createStaticLayout(mOpenSpannableStr); mOpenHeight = layout.getHeight() + getPaddingTop() + getPaddingBottom(); executeOpenAnim(); } else { ExpandableTextView.super.setMaxLines(Integer.MAX_VALUE); setText(mOpenSpannableStr); if (mOpenCloseCallback != null) { mOpenCloseCallback.onOpen(); } } } /** * 收起 */ private void close() { if (hasAnimation) { executeCloseAnim(); } else { ExpandableTextView.super.setMaxLines(mMaxLines); setText(mCloseSpannableStr); if (mOpenCloseCallback != null) { mOpenCloseCallback.onClose(); } } } /** * 执行展开动画 */ private void executeOpenAnim() { //创建展开动画 if (mOpenAnim == null) { mOpenAnim = new ExpandCollapseAnimation(this, mCLoseHeight, mOpenHeight); mOpenAnim.setFillAfter(true); mOpenAnim.setAnimationListener(new Animation.AnimationListener() { @Override public void onAnimationStart(Animation animation) { ExpandableTextView.super.setMaxLines(Integer.MAX_VALUE); setText(mOpenSpannableStr); } @Override public void onAnimationEnd(Animation animation) { // 动画结束后textview设置展开的状态 getLayoutParams().height = mOpenHeight; requestLayout(); animating = false; } @Override public void onAnimationRepeat(Animation animation) { } }); } if (animating) { return; } animating = true; clearAnimation(); // 执行动画 startAnimation(mOpenAnim); } /** * 执行收起动画 */ private void executeCloseAnim() { //创建收起动画 if (mCloseAnim == null) { mCloseAnim = new ExpandCollapseAnimation(this, mOpenHeight, mCLoseHeight); mCloseAnim.setFillAfter(true); mCloseAnim.setAnimationListener(new Animation.AnimationListener() { @Override public void onAnimationStart(Animation animation) { } @Override public void onAnimationEnd(Animation animation) { animating = false; ExpandableTextView.super.setMaxLines(mMaxLines); setText(mCloseSpannableStr); getLayoutParams().height = mCLoseHeight; requestLayout(); } @Override public void onAnimationRepeat(Animation animation) { } }); } if (animating) { return; } animating = true; clearAnimation(); // 执行动画 startAnimation(mCloseAnim); } /** * @param spannable * @return */ private Layout createStaticLayout(SpannableStringBuilder spannable) { int contentWidth = initWidth - getPaddingLeft() - getPaddingRight(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { StaticLayout.Builder builder = StaticLayout.Builder.obtain(spannable, 0, spannable.length(), getPaint(), contentWidth); builder.setAlignment(Layout.Alignment.ALIGN_NORMAL); builder.setIncludePad(getIncludeFontPadding()); builder.setLineSpacing(getLineSpacingExtra(), getLineSpacingMultiplier()); return builder.build(); } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) { return new StaticLayout(spannable, getPaint(), contentWidth, Layout.Alignment.ALIGN_NORMAL, getLineSpacingMultiplier(), getLineSpacingExtra(), getIncludeFontPadding()); } else { return new StaticLayout(spannable, getPaint(), contentWidth, Layout.Alignment.ALIGN_NORMAL, getFloatField(&quot;mSpacingMult&quot;, 1f), getFloatField(&quot;mSpacingAdd&quot;, 0f), getIncludeFontPadding()); } } private float getFloatField(String fieldName, float defaultValue) { float value = defaultValue; if (TextUtils.isEmpty(fieldName)) { return value; } try { // 获取该类的所有属性值域 Field[] fields = this.getClass().getDeclaredFields(); for (Field field : fields) { if (TextUtils.equals(fieldName, field.getName())) { value = field.getFloat(this); break; } } } catch (IllegalAccessException e) { e.printStackTrace(); } return value; } /** * @param charSequence * @return */ private SpannableStringBuilder charSequenceToSpannable(@NonNull CharSequence charSequence) { SpannableStringBuilder spannableStringBuilder = null; if (mCharSequenceToSpannableHandler != null) { spannableStringBuilder = mCharSequenceToSpannableHandler.charSequenceToSpannable(charSequence); } if (spannableStringBuilder == null) { spannableStringBuilder = new SpannableStringBuilder(charSequence); } return spannableStringBuilder; } /** * 初始化TextView的可展示宽度 * * @param width */ public void initWidth(int width) { initWidth = width; } @Override public void setMaxLines(int maxLines) { this.mMaxLines = maxLines; super.setMaxLines(maxLines); } /** * 设置展开后缀text * * @param openSuffix */ public void setOpenSuffix(String openSuffix, IOnOpenSuffixSpanListener onOpenSuffixSpanListener) { mOpenSuffixStr = openSuffix; this.onOpenSuffixSpanListener = onOpenSuffixSpanListener; updateOpenSuffixSpan(); } public void setNewOpenSuffix(String openSuffix, IOnOpenSuffixSpanListener onOpenSuffixSpanListener) { mOpenSuffixStr = openSuffix; this.onOpenSuffixSpanListener = onOpenSuffixSpanListener; updateNewOpenSuffixSpan(); } /** * 设置展开后缀文本颜色 * * @param openSuffixColor */ public void setOpenSuffixColor(@ColorInt int openSuffixColor) { mOpenSuffixColor = openSuffixColor; updateOpenSuffixSpan(); } /** * 设置收起后缀text * * @param closeSuffix */ public void setCloseSuffix(String closeSuffix) { mCloseSuffixStr = closeSuffix; updateCloseSuffixSpan(); } /** * 设置收起后缀文本颜色 * * @param closeSuffixColor */ public void setCloseSuffixColor(@ColorInt int closeSuffixColor) { mCloseSuffixColor = closeSuffixColor; updateCloseSuffixSpan(); } /** * 收起后缀是否另起一行 * * @param closeInNewLine */ public void setCloseInNewLine(boolean closeInNewLine) { mCloseInNewLine = closeInNewLine; updateCloseSuffixSpan(); } public interface IOnOpenSuffixSpanListener { void onClick(); } /** * 更新展开后缀Spannable */ private void updateOpenSuffixSpan() { if (TextUtils.isEmpty(mOpenSuffixStr)) { mOpenSuffixSpan = null; return; } mOpenSuffixSpan = new SpannableString(mOpenSuffixStr); mOpenSuffixSpan.setSpan(new ClickableSpan() { @Override public void onClick(@NonNull View widget) { if (onOpenSuffixSpanListener != null) { onOpenSuffixSpanListener.onClick(); } else { switchOpenClose(); } } @Override public void updateDrawState(@NonNull TextPaint ds) { super.updateDrawState(ds); ds.setColor(mOpenSuffixColor); ds.setUnderlineText(false); } }, 0, mOpenSuffixStr.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); } private void updateNewOpenSuffixSpan() { if (TextUtils.isEmpty(mOpenSuffixStr)) { mOpenSuffixSpan = null; return; } mOpenSuffixSpan = new SpannableString(mOpenSuffixStr); mOpenSuffixSpan.setSpan(new ClickableSpan() { @Override public void onClick(@NonNull View widget) { if (onOpenSuffixSpanListener != null) { onOpenSuffixSpanListener.onClick(); } else { switchOpenClose(); } } @Override public void updateDrawState(@NonNull TextPaint ds) { super.updateDrawState(ds); ds.setColor(mOpenSuffixColor); ds.setUnderlineText(false); } }, 0, mOpenSuffixStr.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); } /** * 更新收起后缀Spannable */ private void updateCloseSuffixSpan() { if (TextUtils.isEmpty(mCloseSuffixStr)) { mCloseSuffixSpan = null; return; } mCloseSuffixSpan = new SpannableString(mCloseSuffixStr); mCloseSuffixSpan.setSpan(new StyleSpan(android.graphics.Typeface.BOLD), 0, mCloseSuffixStr.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); if (mCloseInNewLine) { AlignmentSpan alignmentSpan = new AlignmentSpan.Standard(Layout.Alignment.ALIGN_OPPOSITE); mCloseSuffixSpan.setSpan(alignmentSpan, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); } mCloseSuffixSpan.setSpan(new ClickableSpan() { @Override public void onClick(@NonNull View widget) { switchOpenClose(); } @Override public void updateDrawState(@NonNull TextPaint ds) { super.updateDrawState(ds); ds.setColor(mCloseSuffixColor); ds.setUnderlineText(false); } }, 1, mCloseSuffixStr.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); } public void setContentClickListener(View.OnClickListener onClickListener) { mOnClickListener = onClickListener; } public OpenAndCloseCallback mOpenCloseCallback; public void setOpenAndCloseCallback(OpenAndCloseCallback callback) { this.mOpenCloseCallback = callback; } public interface OpenAndCloseCallback { void onOpen(); void onClose(); } /** * 设置文本内容处理 * * @param handler */ public void setCharSequenceToSpannableHandler(CharSequenceToSpannableHandler handler) { mCharSequenceToSpannableHandler = handler; } public interface CharSequenceToSpannableHandler { @NonNull SpannableStringBuilder charSequenceToSpannable(CharSequence charSequence); } class ExpandCollapseAnimation extends Animation { private final View mTargetView;//动画执行view private final int mStartHeight;//动画执行的开始高度 private final int mEndHeight;//动画结束后的高度 ExpandCollapseAnimation(View target, int startHeight, int endHeight) { mTargetView = target; mStartHeight = startHeight; mEndHeight = endHeight; setDuration(400); } @Override protected void applyTransformation(float interpolatedTime, Transformation t) { mTargetView.setScrollY(0); //计算出每次应该显示的高度,改变执行view的高度，实现动画 mTargetView.getLayoutParams().height = (int) ((mEndHeight - mStartHeight) * interpolatedTime + mStartHeight); mTargetView.requestLayout(); } }} 控件使用方式 123456789101112131415161718192021222324252627282930313233343536val tvContent = holder.getView&lt;ExpandableTextView&gt;(R.id.tv_content)tvContent.movementMethod = LinkMovementMethod.getInstance()tvContent.isClickable = falsetvContent.isLongClickable = falseval builder = SpannableStringBuilder()if (item.spoiler &amp;&amp; spoilerEnable) builder.append(&quot; &quot;)if (item.talkList != null &amp;&amp; item.talkList.size &gt; 0) { val talk = item.talkList[0] val startIndex = builder.length builder.append(&quot;#&quot;) builder.append(talk.name) builder.append(&quot; &quot;) val clickableSpan = object : ClickableSpan() { override fun onClick(view: View) { talkClickListener?.invoke(item, holder.adapterPosition) } override fun updateDrawState(ds: TextPaint) { ds.color = if (talk.enable) Color.parseColor(&quot;#1890FF&quot;) else Color.parseColor(&quot;#85888F&quot;) } } builder.setSpan( clickableSpan, startIndex, builder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE )}builder.append(it)tvContent.initWidth(UiUtils.getScreenWidth() - UiUtils.dip2px(16 * 2 + 36 + 9))tvContent.setOpenSuffix(&quot;查看全文&quot;) { listener.invoke(item, null)}tvContent.setOriginalText(builder)","link":"/blog/2022/02/16/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80-SpannableString%E4%B9%8B%E6%98%BE%E7%A4%BA%E6%9F%A5%E7%9C%8B%E5%85%A8%E6%96%87/"}],"tags":[{"name":"Android","slug":"Android","link":"/blog/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","link":"/blog/tags/Kotlin/"},{"name":"H5","slug":"H5","link":"/blog/tags/H5/"},{"name":"JsBridge","slug":"JsBridge","link":"/blog/tags/JsBridge/"},{"name":"adb","slug":"adb","link":"/blog/tags/adb/"},{"name":"FileProvider","slug":"FileProvider","link":"/blog/tags/FileProvider/"},{"name":"Shortcuts","slug":"Shortcuts","link":"/blog/tags/Shortcuts/"},{"name":"ExoPlayer","slug":"ExoPlayer","link":"/blog/tags/ExoPlayer/"},{"name":"Git","slug":"Git","link":"/blog/tags/Git/"},{"name":"Gradle","slug":"Gradle","link":"/blog/tags/Gradle/"},{"name":"Gson","slug":"Gson","link":"/blog/tags/Gson/"},{"name":"Hexo","slug":"Hexo","link":"/blog/tags/Hexo/"},{"name":"NexT","slug":"NexT","link":"/blog/tags/NexT/"},{"name":"Homebrew","slug":"Homebrew","link":"/blog/tags/Homebrew/"},{"name":"Java","slug":"Java","link":"/blog/tags/Java/"},{"name":"Problems专题","slug":"Problems专题","link":"/blog/tags/Problems%E4%B8%93%E9%A2%98/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/blog/tags/RecyclerView/"},{"name":"Python","slug":"Python","link":"/blog/tags/Python/"},{"name":"Shell","slug":"Shell","link":"/blog/tags/Shell/"},{"name":"Proxy","slug":"Proxy","link":"/blog/tags/Proxy/"},{"name":"Vim","slug":"Vim","link":"/blog/tags/Vim/"},{"name":"SSH","slug":"SSH","link":"/blog/tags/SSH/"},{"name":"iTerm2","slug":"iTerm2","link":"/blog/tags/iTerm2/"},{"name":"Reading","slug":"Reading","link":"/blog/tags/Reading/"},{"name":"Aria","slug":"Aria","link":"/blog/tags/Aria/"},{"name":"下载","slug":"下载","link":"/blog/tags/%E4%B8%8B%E8%BD%BD/"},{"name":"源码","slug":"源码","link":"/blog/tags/%E6%BA%90%E7%A0%81/"},{"name":"算法","slug":"算法","link":"/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"Netty","slug":"Netty","link":"/blog/tags/Netty/"}],"categories":[],"pages":[{"title":"404","text":"","link":"/blog/404/index.html"},{"title":"关于小站","text":"Dench Home-boy Developer Gamer Android Flutter","link":"/blog/about/index.html"},{"title":"Categories","text":"","link":"/blog/categories/index.html"},{"title":"Tags","text":"","link":"/blog/tags/index.html"}]}